---
title: "Data_analysis"
output:
  html_notebook:
    toc: yes
    toc_depth: 4
    toc_float: true
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, tidy = TRUE, highlight = TRUE, cache = TRUE)
```

```{r, echo = F, message=FALSE}
# data wrangling
library(tidyverse)
library(broom)
library(readxl)
library(httr)

# report 
library(knitr)

# plotting
library(scales)
library(gridExtra)
library(GGally)
library(cowplot)
library(corrplot)

# data analysis
library(phyloseq)
#library(VennDiagram)
library(DESeq2)
library(vegan)
library(cvTools)
library(car)
library(ape)
library(quantreg)
```


read in and join data

```{r}
meta <- read_tsv("https://ndownloader.figshare.com/files/10683334")

# Nitrogen fixation data 
# Unit: µmol Ethen / gram ww Sediment / day

GET("https://ndownloader.figshare.com/files/10683343", write_disk(tf <- tempfile(fileext = ".xlsx")))

N_func <- read_excel(tf, "final_data") %>% 
  mutate(N2_fixation = eten_μmol_g_day/3)  #eten to N2

# nifH abundance data
# Unit: copies per Gramm sediment wet weight


GET("https://ndownloader.figshare.com/files/10683349", write_disk(tf2 <- tempfile(fileext = ".xlsx")))

qPCR <- read_excel(tf2, "final_data") %>% 
  dplyr::rename(nifH = nifH_cop_g_sediment)


# fraction nifH parralogues
Par_frct <- read.table("https://ndownloader.figshare.com/files/10683358", sep ="\t", 
                       header = T, stringsAsFactors = FALSE)


FuncDat_raw <- 
  meta %>% 
  mutate(habitat = ifelse(Level == 1, sediment, "mix")) %>% 
  select(-habitat) %>% 
  left_join(N_func) %>% 
  left_join(qPCR) %>% 
  left_join(Par_frct) %>% 
  arrange(Level, replicate, sediment)


```
 
+ Nitrogen fixation by habitat diversity level

```{r}
N2 <- 
FuncDat_raw %>% 
  ggplot(., aes(Level, N2_fixation, fill = sediment)) +
  geom_point(shape = 21, position = position_dodge(width = 0.4), size = 3, colour = "grey")+
  stat_summary(fun.y = function(x) mean(x), geom = "point", aes(group = Level), shape = 23 , size = 4)+
  stat_smooth(method = "lm", se = F, size = 0.5, colour = "black", aes(group = 1))+
  theme_classic()+
  scale_fill_manual(values = c("cyan4", "forestgreen", 
                               "tan2", "brown4"),
 guide_legend(title = "", legend.text = ""))+
  theme(legend.position =  "bottom")+
  labs(y = expression(N[2]~(µmol~g^-1~d^-1)), 
                 x = "habitat diversity", 
                 title = "N2 fixation")
  
  N2       

```

We want to know if we can explain the residual variation in N2 fixation that cannot be attributed to habitat diversity. Therefore we first statistically remove the effect of habitat diversity (such that the mean N_2 fixation is the same for all habitat diversity levels). 

```{r}
FuncDat_raw <- FuncDat_raw %>% 
  mutate(N2_fixation = resid(lm(N2_fixation ~ Level, data = .))) %>% 
  mutate(N2_fixation = N2_fixation + abs(min(N2_fixation)))

ResidN2 <- 
ggplot(FuncDat_raw, aes(x = Level, y = N2_fixation, fill = sediment)) +
  geom_point(shape = 21, position = position_dodge(width = 0.4), size = 3, colour = "grey")+
  stat_summary(fun.y = function(x) mean(x), geom = "point", aes(group = Level), shape = 23 , size = 4)+
  stat_smooth(method = "lm", se = F, size = 0.5, colour = "black", aes(group = 1))+
  theme_classic()+
  scale_fill_manual(values = c("cyan4", "forestgreen", 
                               "tan2", "brown4"),
                    guide = guide_legend(override.aes = 
                                           list(color = "white",
                                                fill = "white")))+
  theme(legend.position = "bottom",
        legend.text = element_text(color = "white"),
        legend.title = element_text(color = "white"),
        legend.key = element_rect(fill = "white",colour = "white"))+ 
  labs(y = expression(residual~N[2]~fixation~(µmol~g^-1~d^-1)),
                      x = "habitat diversity", 
       title = "residual N2 fixation")

ResidN2
```

```{r}
Figure_S4 <- arrangeGrob(N2, ResidN2, nrow = 1) 

ggsave("Figure_S4.png", Figure_S4, width = 6, height = 3)
ggsave("Figure_S4.pdf", Figure_S4, width = 6, height = 3)
```

```{r}
grid.arrange(N2, ResidN2, nrow = 1) 
```



#nifH data from Andersson et al 2014

Andersson, B., Sundbäck, K., Hellman, M., Hallin, S., & Alsterberg, C. (2014). Nitrogen fixation in shallow-water sediments: Spatial distribution and controlling factors. Limnology and Oceanography, 59(6), 1932–1944. http://doi.org/10.4319/lo.2014.59.6.1932


```{r}
# Nitrogen fixation is in *µmol Ethylen x gram^-1 w/w sed. x day^-1*
# nifH abundance is in *copies nifH x mili-gram^-1 w/w sed.*

GET("https://ndownloader.figshare.com/files/10683367", write_disk(tf3 <- tempfile(fileext = ".xlsx")))

Andersson <- read_excel(tf3, sheet = "final_data")

Andersson <- 
  Andersson[,c(1:3)] %>% 
    mutate(N2_fixation = NA_ymol_gws_d/3) %>%  #  Ethen to N2
    mutate(nifH = nifH_kopior_mg_ww * 1000) %>% # mg to gram   
    na.omit()

# we make the correlatin in log -log   
Andersson_log10 <-  mutate_at(Andersson, vars(nifH, N2_fixation), log)
  
mod_nifH_And <- lm(N2_fixation ~ nifH, Andersson_log10)

glance(mod_nifH_And)

PRED_PI_A <- 
predict(mod_nifH_And, data = Andersson, interval = "predict", type = "response") %>% 
  data.frame %>% 
  mutate_all(function(x) exp(x)) %>% 
  mutate(nifH = Andersson$nifH) 

PRED_CI_A <- 
predict(mod_nifH_And, data = Andersson, interval = "confidence", type = "response") %>% 
  data.frame %>% 
  mutate_all(function(x) exp(x)) %>% 
  mutate(nifH = Andersson$nifH) 

Andersson_plot <- 
ggplot(Andersson)+
  geom_point(aes(x = nifH, y = N2_fixation), shape = 21, size = 2, colour = "black", fill = "#377eb8")+
  geom_ribbon(data = PRED_PI_A, aes(x = nifH, ymin = lwr, ymax = upr), alpha = 0.1)+
 geom_ribbon(data = PRED_CI_A, aes(x = nifH, ymin = lwr, ymax = upr), alpha = 0.3)+
  geom_line(data = PRED_PI_A, aes(x = nifH, y = fit))+
  theme_bw()+
  scale_y_log10()+
  scale_x_log10(breaks = 10^seq(0,15,1))+
  labs(y = expression(N[2]~(µmol~g^-1~d^-1)),
       x = expression(nifH~(copies~g^-1)))

Andersson_plot
```


+ comparing the range of values for nifH abundance and N2 fixation from Andersson et al and Alsterberg et al

```{r}
DF_comp <- data.frame(Exp = rep(c(rep("Alsterberg", nrow(FuncDat_raw)), rep("Andersson", nrow(Andersson))), 2))

DF_comp$Var <- rep(c("nifH", "Nfix"), each = nrow(DF_comp)/2)

DF_comp$Val <- c(c(FuncDat_raw$nifH, Andersson$nifH), c(FuncDat_raw$N2_fixation, Andersson$N2_fixation))

DF_comp$Var <- factor(DF_comp$Var, levels = c("nifH", "Nfix"))

ggplot(DF_comp,  aes(x = Val, fill = Exp))+
  geom_histogram(alpha = 0.6, position = "identity")+
  facet_wrap(~Var, scales = "free_x")+
  scale_x_log10()+
  theme_bw()+
  scale_fill_manual(values = c("#a50f15", "#377eb8"))

```



#predicting N2_fixation in our data 

Here we take the model fitted to the data from Andersson et al and attempt to predict nitrogen fixation on our data

```{r}

Pred_Nfix <- 
FuncDat_raw %>%
  select(nifH, N2_fixation) %>% 
  mutate_all(log) %>% 
  predict(mod_nifH_And, newdata = ., interval= "prediction", type = "response") %>% 
  as.data.frame() %>% 
  mutate_all(function(x) exp(x)) %>% 
  cbind(select(FuncDat_raw, nifH, N2_fixation))

  
Alsterberg_plot <- 
ggplot(Pred_Nfix)+
  geom_point(aes(x = nifH, y = N2_fixation), 
             shape = 21, size = 2, colour = "black", fill = "#377eb8")+
  geom_ribbon( aes(x = nifH, ymin = lwr, ymax = upr), alpha = 0.1)+
  geom_line(aes(x = nifH, y = fit))+
 # geom_hline(aes(x = nifH, yintercept =  mean(N2_fixation)), size = 0.3)+
  geom_hline(aes(x = nifH, yintercept =  exp(mean(log(N2_fixation)))), size = 0.3)+
  theme_classic()+
  scale_y_log10()+
  scale_x_log10(breaks = 10^seq(0,10,1))+
  labs(y = expression(N[2]~(µmol~g^-1~d^-1)),
       x = expression(nifH~(copies~g^-1)))

Alsterberg_plot

```




```{r}


Figure_1_data <- 
Andersson %>% 
  select(N2_fixation) %>% 
  cbind(PRED_PI_A) %>% 
  mutate(Exp = "Andersson") %>% 
  rbind(., mutate(Pred_Nfix, Exp = "Alsterberg")) %>% 
  mutate(Exp = factor(Exp, levels = c("Andersson", "Alsterberg"),
                      labels = c("Andersson et al.",
                                 "Alsterberg et al."))) %>% 
  filter(N2_fixation > 0) %>% 
  group_by(Exp) %>% 
  mutate(Mean = exp(mean(log(N2_fixation))))


  
Figure_1_full_range <- ggplot(Figure_1_data, aes(x = nifH, y = N2_fixation, fill = Exp))+
  geom_point(shape = 21, size = 2, colour = "black")+
  geom_ribbon( aes(x = nifH, ymin = lwr, ymax = upr), alpha = 0.1, fill = "black")+
  geom_line(aes(x = nifH, y = fit))+
  geom_line(aes(x = nifH, y = Mean), size = 0.3, linetype = "dashed")+
  facet_wrap(~Exp)+
  geom_text(data = data.frame(Exp = c("Andersson et al.",
                                      "Alsterberg et al."),
                              x = 10^5, y = 10^-0.5,
                              label = c("a", "b")), 
            aes(x = x, y=y, label = label), fontface = "bold")+
  scale_x_log10(
        breaks = trans_breaks("log10", function(x) 10^x),
        labels = trans_format("log10", math_format(10^.x)),
        limits=c(1e5,1e7))+
  scale_y_log10(
        breaks = trans_breaks("log10", function(x) 10^x),
       labels = trans_format("log10", math_format(10^.x)),
       limits = c(1e-7,1))+
  scale_fill_manual(values = c( "#377eb8", "#a50f15"))+
  labs(x = expression(nifH~(copies~g^-1)),
       y = expression(N[2]~(µmol~g^-1~d^-1)),
       fill = "Study")+
  theme_bw()+
  theme(legend.position = "none")

Figure_1_full_range
```

## In range prediction

The prediction above used the full range of values for both the Andersson et al and the Alsterberg et al dataset. Yet, this implies out-of-range prediction as the lowest nifH copie numbers observed in Andersson et al are lower than for Andersson et al. Furthermore the shape of the relationship in the data in Andersson et al could be different if we only consider the range of data covered by Alsterberg et al. As a more conservative test of the predictive ability of nifH copie numbers and the transferrability across datasets, we fitt the model and predict with only the shared range of nifH copie numbers.

```{r}
select(Andersson, N2_fixation, nifH) %>% 
  mutate(DF = "Andersson") %>% 
  rbind(mutate( select( FuncDat_raw, N2_fixation, nifH), DF = "Alsterberg")) %>% 
  mutate(Range = NA) %>% 
  mutate(Range = ifelse(nifH >= min(Andersson$nifH), "yes", "no")) %>% 
  mutate(Range = ifelse(nifH > max(FuncDat_raw$nifH), "no", Range)) %>% 
  ggplot(aes(x = nifH, y = N2_fixation, fill = DF, alpha = Range))+
  geom_point(shape = 21, size = 2)+
  scale_x_log10()+
  scale_y_log10()+
  theme_bw()+
  scale_fill_manual(values = c("#a50f15", "#377eb8"))+
  scale_alpha_manual(values = c(0.4, 1))+
  labs(title = "common range of nifH copie numbers")
```


```{r}
#truncate Andersson et al data to range observed values in Alsterberg et al
Andersson_range <- filter(Andersson, nifH <= max(FuncDat_raw$nifH))

# we make the correlation in log - log   
Andersson_range_log <-  mutate_at(Andersson_range, vars(nifH, N2_fixation), log)

mod_nifH_And_range <- lm(N2_fixation ~ nifH, Andersson_range_log)

tidy(mod_nifH_And_range) %>% 
  mutate_if(is.numeric, signif, 2)

glance(mod_nifH_And_range) %>% 
  mutate_if(is.numeric, signif, 2)
```

the model for the truncated range is still significant (p =  0.007) but the goodness of fits drops down to 18%
(R-square = 0.18)

```{r}
PRED_PI_A_range <- 
predict(mod_nifH_And_range, data = Andersson_range, interval = "predict", type = "response") %>% 
  data.frame %>% 
  mutate_all(function(x) exp(x)) %>% 
  mutate(nifH = Andersson_range$nifH) 

PRED_CI_A_range <- 
predict(mod_nifH_And_range, data = Andersson_range, interval = "confidence", type = "response") %>% 
  data.frame %>% 
  mutate_all(function(x) exp(x)) %>% 
  mutate(nifH = Andersson_range$nifH) 

Andersson_plot_range <- 
ggplot(Andersson_range)+
  geom_point(aes(x = nifH, y = N2_fixation), shape = 21, size = 2, colour = "black", fill = "#377eb8")+
  geom_ribbon(data = PRED_PI_A_range, aes(x = nifH, ymin = lwr, ymax = upr), alpha = 0.1)+
 geom_ribbon(data = PRED_CI_A_range, aes(x = nifH, ymin = lwr, ymax = upr), alpha = 0.3)+
  geom_line(data = PRED_PI_A_range, aes(x = nifH, y = fit))+
  theme_bw()+
  scale_y_log10()+
  scale_x_log10(breaks = 10^seq(0,15,1))+
  labs(y = expression(N[2]~(µmol~g^-1~d^-1)),
       x = expression(nifH~(copies~g^-1)))

Andersson_plot_range
```


```{r}

Pred_Nfix_range <- 
FuncDat_raw %>%
  select(nifH, N2_fixation) %>% 
  filter(nifH >= min(Andersson_range$nifH)) %>% 
  mutate_all(log) %>% 
  predict(mod_nifH_And_range, newdata = ., interval= "prediction", type = "response") %>% 
  as.data.frame() %>% 
  mutate_all(function(x) exp(x)) %>% 
  cbind(select(filter(FuncDat_raw, nifH >= min(Andersson_range$nifH)),
               nifH, N2_fixation))

  
Alsterberg_plot_range <- 
ggplot(Pred_Nfix_range)+
  geom_point(aes(x = nifH, y = N2_fixation), 
             shape = 21, size = 2, colour = "black", fill = "#377eb8")+
  geom_ribbon( aes(x = nifH, ymin = lwr, ymax = upr), alpha = 0.1)+
  geom_line(aes(x = nifH, y = fit))+
 # geom_hline(aes(x = nifH, yintercept =  mean(N2_fixation)), size = 0.3)+
  geom_hline(aes(x = nifH, yintercept =  exp(mean(log(N2_fixation)))), size = 0.3)+
  theme_classic()+
  scale_y_log10()+
  scale_x_log10(breaks = 10^seq(0,10,1))+
  labs(y = expression(N[2]~(µmol~g^-1~d^-1)),
       x = expression(nifH~(copies~g^-1)))

Alsterberg_plot_range

```

```{r}


Figure_1_in_range_data <- 
Andersson_range %>% 
  select(N2_fixation) %>% 
  cbind(PRED_PI_A_range) %>% 
  mutate(Exp = "Andersson") %>% 
  rbind(., mutate(Pred_Nfix_range, Exp = "Alsterberg")) %>% 
  mutate(Exp = factor(Exp, levels = c("Andersson", "Alsterberg"),
                      labels = c("Andersson et al.",
                                 "Alsterberg et al."))) %>% 
  filter(N2_fixation > 0) %>% 
  group_by(Exp) %>% 
  mutate(Mean = exp(mean(log(N2_fixation))))


Figure_1_in_range <- 
  ggplot(Figure_1_in_range_data, aes(x = nifH, y = N2_fixation, fill = Exp))+
  geom_point(shape = 21, size = 2, colour = "black")+
  geom_ribbon( aes(x = nifH, ymin = lwr, ymax = upr), alpha = 0.1, fill = "black")+
  geom_line(aes(x = nifH, y = fit))+
  geom_line(aes(x = nifH, y = Mean), size = 0.3, linetype = "dashed")+
  facet_wrap(~Exp)+
  geom_text(data = data.frame(Exp = c("Andersson et al.",
                                      "Alsterberg et al."),
                              x = 10^5, y = 10^-0.5,
                              label = c("a", "b")), 
            aes(x = x, y=y, label = label), fontface = "bold")+
  scale_x_log10(
        breaks = trans_breaks("log10", function(x) 10^x),
        labels = trans_format("log10", math_format(10^.x)),
        limits=c(1e5,1e7))+
  scale_y_log10(
        breaks = trans_breaks("log10", function(x) 10^x),
       labels = trans_format("log10", math_format(10^.x)),
       limits=c(1e-7,1))+
  scale_fill_manual(values = c( "#377eb8", "#a50f15"))+
  labs(x = expression(nifH~(copies~g^-1)),
       y = expression(N[2]~(µmol~g^-1~d^-1)),
       fill = "Study")+
  theme_bw()+
  theme(legend.position = "none")

#ggsave("Figure_1.pdf", plot = Figure_1, width = 7, height = 4)
#ggsave("Figure_1.jpeg", plot = Figure_1, width = 7, height = 4)

Figure_1_in_range
```

+ prediction statistics

```{r}
data.frame(
  FOR = c("full range", "full range", "common range", "common range"),
  BY = c("Andersson et al", "Intercept", "Andersson et al", "Intercept"),
  rmspe = c(rmspe(Pred_Nfix$N2_fixation, Pred_Nfix$fit),
            rmspe(Pred_Nfix$N2_fixation, mean(Pred_Nfix$N2_fixation)),
            rmspe(Pred_Nfix_range$N2_fixation, Pred_Nfix_range$fit),
            rmspe(Pred_Nfix_range$N2_fixation, mean(Pred_Nfix_range$N2_fixation)))
) %>% 
  mutate(rmspe = signif(rmspe, 2))
```

## Figure 1

```{r}
Figure_1 <- 
Figure_1_in_range_data %>% 
  mutate(in_range = "common range") %>% 
  bind_rows(mutate(Figure_1_data, in_range = "full range")) %>% 
  mutate(in_range = factor(in_range, levels = c("full range", "common range"))) %>% 
  ggplot(., aes(x = nifH, y = N2_fixation, fill = Exp))+
  geom_point(shape = 21, size = 2, colour = "black")+
  geom_ribbon( aes(x = nifH, ymin = lwr, ymax = upr), alpha = 0.1, fill = "black")+
  geom_line(aes(x = nifH, y = fit))+
  geom_line(aes(x = nifH, y = Mean), size = 0.3, linetype = "dashed")+
  facet_grid(in_range~Exp)+
  scale_x_log10(
        breaks = trans_breaks("log10", function(x) 10^x),
        labels = trans_format("log10", math_format(10^.x)))+
  scale_y_log10(
        breaks = trans_breaks("log10", function(x) 10^x),
       labels = trans_format("log10", math_format(10^.x)))+
  scale_fill_manual(values = c( "#377eb8", "#a50f15"))+
  labs(x = expression(nifH~(copies~g^-1)),
       y = expression(dinitrogen~fixation~(µmol~N[2]~g^-1~d^-1)),
       fill = "Study")+
  theme_bw()+
  theme(legend.position = "none")


ggsave("Figure_1.pdf", plot = Figure_1, width = 7, height = 5)
ggsave("Figure_1.jpeg", plot = Figure_1, width = 7, height = 5)

Figure_1
```


# Hypothesis 1

How much of the variation in process rate can we predict with community metrics

+ 16S diversity 
+ nif_h diversity
+ nif_h abundance
+ habitat type

below I show the distribution of the *predictor* variables in the four sediment types.


```{r}
DIV <- read.table("Diversity_estimations.txt")

FuncDat_raw <- 
  DIV %>%
  select(-contains("S_")) %>% 
  select(-contains("y_")) %>% 
  na.omit() %>% 
  left_join(FuncDat_raw) %>%
  select(-contains("phylo"), -contains("nosz")) %>% 
  select(-MC.ID, -replicate, -season, -weight)


FuncDat <- FuncDat_raw %>% 
  mutate(corr_nifH = nifH * (1 - frct.par))

FuncDat %>% 
  select(effN_nifh, effN_bac, corr_nifH, sediment) %>% 
  ggpairs(aes(colour = sediment)) %>% 
  print(., progress = FALSE)
  
  
  
```

### regression diag

```{r}

gg_diag <- function(x) {
  FF <- augment(x)
  p1 <- 
    ggplot(FF, aes(.fitted, .resid))+
    geom_point() +
    geom_hline(yintercept=0, col="red", linetype="dashed")+
    stat_smooth(method = "loess", se = F, size = 0.5)+
    theme_bw(base_size = 8)+
    labs(x = "Fitted values", y = "Residuals", title = "residual against fitted")
    
  p2 <- 
    ggplot(FF, aes(sample = .std.resid))+
    geom_point(stat = "qq")+
    labs(x = "Theoretical Quantiles", y = "Standardized Residuals", title = "Normal Q-Q")+
    theme_bw(base_size = 8)
  
  p3 <- 
    ggplot(FF, aes(.fitted, sqrt(abs(.std.resid))))+
    geom_point(na.rm=TRUE)+
    geom_hline(aes(yintercept = mean(sqrt(abs(.std.resid)))), col="red", linetype="dashed")+
    stat_smooth(method = "loess", se = F, size = 0.5)+
    labs(y =(expression(sqrt("|Standardized residuals|"))),
         title = paste("ncvTest: p = ", signif(ncvTest(x)$p, 2), sep = ""))+
    theme_bw(base_size = 8)
    
    
  p4 <-  
    ggplot(FF, aes(x =  .resid))+
    geom_histogram(bins = 10, aes(y=..density..,), fill = "white", colour = "black")+
    stat_function(
    fun = function(x, n, bw){ 
      dnorm(x = x, mean = mean(x), sd = sd(x)) }, colour = "red") +
    labs(title = paste("Shapiro-Wilk: p = ", signif(tidy(shapiro.test(residuals(x)))$p.value, 2)), sep = "")+
    theme_bw(base_size = 8)
  
  grid.arrange(p1, p2, p3, p4) }
  

```

### summary community metrics

```{r}
FuncDat %>% 
  select(-Level, -sample) %>% 
  gather(variable, value, -sediment) %>% 
  group_by(sediment, variable) %>% 
  summarise_at("value", .funs = c("min", "max", "mean", "median")) %>% 
  arrange(variable, sediment) %>% 
  mutate_if(is.numeric, signif, 3) %>% 
  mutate_if(is.numeric, format, scientific=FALSE) 
  
```

```{r}

FuncDat %>% 
  select(-Level, -sample) %>% 
  gather(variable, value, -sediment) %>% 
  group_by(variable) %>% 
  nest() %>% 
  mutate(Model = map(data, function(x) lm(value ~ sediment, data = x))) %>% 
  mutate(glance_lm=Model %>% map(glance),
         `F-statistic` = glance_lm %>% map_dbl("statistic"),
         rsq=glance_lm %>% map_dbl("r.squared"),
         pval=glance_lm %>% map_dbl("p.value"),
         df = glance_lm %>% map_dbl("df"),
         df.residual = glance_lm %>% map_dbl("df.residual")) %>% 
  mutate_if(is.numeric, signif, 2) %>% 
  select(-data, -Model, -glance_lm )
      
  
```

```{r}
lm(effN_nifh ~ effN_bac, data = FuncDat) %>% 
  glance()
```

```{r}
lm(effN_nifh ~ corr_nifH, data = FuncDat) %>% 
  glance()
```


### regression effN_bac (excluded from manuscript)
```{r}

mod_16Sdiv <-  lm(sqrt(N2_fixation) ~ effN_bac, FuncDat)

mod_16S_g <- mod_16Sdiv %>% glance

gg_diag(mod_16Sdiv)

plot_16Sdiv <-
  ggplot(FuncDat_raw)+
  geom_point(aes(x = effN_bac, y = N2_fixation,
                 fill = sediment), 
             colour = "black", size = 3, alpha = 0.8, shape = 21)+
  geom_segment(aes(x = min(effN_bac), 
                   xend = max(effN_bac), 
                   y = mean(N2_fixation),
                   yend = mean(N2_fixation)),
               colour = "grey", linetype = "dashed")+
  annotate("label", x = 0.7 * max(FuncDat$effN_bac), y = 0.12,  
           label.size = 0,
           label = paste("bacterial diversity",
                         paste("p", round(mod_16S_g$p.value, 2)), sep= "\n"),
           alpha = 0.5)+
  theme_bw(base_size = 12)+
  labs(x = "effective number of bacterial otus",
       y = expression(dinitrogen~fixation~(µmol~N[2]~g^-1~d^-1)))+
  #scale_y_continuous(limits = c(-13,55))+
  scale_y_sqrt(breaks=c(0.01,0.04, 0.08, 0.15))+
  scale_x_continuous(limits = c(0,NA))+
  theme(legend.position = "none")+
  scale_fill_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))



plot_16Sdiv


```

### regression effN_nifh
```{r}

mod_nifh <-  lm(sqrt(N2_fixation) ~ effN_nifh, FuncDat)

mod_nifh_g <- mod_nifh %>% glance

gg_diag(mod_nifh)

plot_nifh <-
  ggplot(FuncDat_raw)+
  geom_point(aes(x = effN_nifh, y = N2_fixation, 
                 fill = sediment), 
             colour = "black", size = 3, alpha = 0.8, shape = 21)+
  geom_segment(aes(x = min(effN_nifh), 
                   xend = max(effN_nifh), 
                   y = mean(N2_fixation),
                   yend = mean(N2_fixation)),
               colour = "grey", linetype = "dashed")+
  annotate("label", x = 0.7 * max(FuncDat$effN_nifh), y = 0.12, 
           label.size = 0,
           label = paste("nifH diversity",
                         paste("p", round(mod_nifh_g$p.value, 2)), sep= "\n"),
                         alpha = 0.5)+
  theme_bw(base_size = 10)+
  labs(x = "effective number of nifH otus", 
       y = expression(dinitrogen~fixation~(µmol~N[2]~g^-1~d^-1)))+
  #scale_y_continuous(limits = c(-13,55))+
  scale_y_sqrt(breaks=c(0.01,0.04, 0.08, 0.15))+
  scale_x_continuous(limits = c(0,NA))+
  theme(legend.position = "none")+
  scale_fill_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))


plot_nifh

```

### regression corr_nifH
```{r}

mod_nifH_ab <-  lm(sqrt(N2_fixation) ~ corr_nifH, FuncDat)

mod_nifH_ab_g <- mod_nifH_ab %>% glance

gg_diag(mod_nifH_ab)

plot_nifH_ab  <-
  ggplot(FuncDat)+
  geom_point(aes(x = corr_nifH, y = N2_fixation, 
                 fill = sediment), 
              colour = "black", size = 3, alpha = 0.8, shape = 21)+
  geom_segment(aes(x = min(corr_nifH), 
                   xend = max(corr_nifH), 
                   y = mean(N2_fixation),
                   yend = mean(N2_fixation)),
               colour = "grey", linetype = "dashed")+
  annotate("label", x = 0.7 * max(FuncDat$corr_nifH), y = 0.12, 
           label.size = 0,
           label = paste("corrected nifH abundance",
                         paste("p", round(mod_nifH_ab_g$p.value, 2)),
                         sep= "\n"),
                         alpha = 0.5)+
  theme_bw(base_size = 10)+
  labs(x = expression(corrected~nifH~(copies~g^-1)),
       y = expression(dinitrogen~fixation~(µmol~N[2]~g^-1~d^-1)))+
  #scale_y_continuous(limits = c(-13,55))+
  scale_y_sqrt(breaks=c(0.01,0.04, 0.08, 0.15))+
  scale_x_continuous(limits = c(0,NA))+
  theme(legend.position = "none")+
  scale_fill_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))


plot_nifH_ab

```

### quantile regression

```{r}
tidy(rq(N2_fixation ~ corr_nifH, data=FuncDat, tau = 0.2))

```


### regression sediment
```{r}

mod_hab <-  lm(sqrt(N2_fixation) ~ sediment, FuncDat)

mod_hab_g <- mod_hab %>% glance

gg_diag(mod_hab)

Pred <- predict(mod_hab, interval = "confidence", type = "response") %>% 
  data.frame() %>% 
  mutate_all(function(x) x^2) %>% 
  mutate(sediment = FuncDat$sediment) %>% 
  group_by(sediment) %>% 
  summarise_all(mean) 

plot_hab <-
  ggplot(FuncDat)+
  geom_point(aes(x = sediment, y = N2_fixation, 
                 fill = sediment), 
              colour = "black", size = 3, alpha = 0.8,
             position = position_jitter(width = 0.1), shape = 21)+
  geom_crossbar(data = Pred, aes(x = sediment, 
                                 y = fit, 
                                 ymin = lwr,
                                 ymax = upr),
                alpha = 0.3, width = 0.3, fill = "grey", size = 0.1)+
  annotate("label", x = 3.5, y = 0.12, 
           label.size = 0,
           label = paste("sediment types","\n",
                         paste("R2", round(mod_hab_g$r.squared, 2))," ; ",
                         paste("p", round(mod_hab_g$p.value, 3)), sep = ""),
                         alpha = 0.7)+
  theme_bw(base_size = 10)+
  labs(x = "sediment types",
       y = expression(dinitrogen~fixation~(µmol~N[2]~g^-1~d^-1)))+
  #scale_y_continuous(limits = c(-13,55))+
  scale_y_sqrt(breaks=c(0.01,0.04, 0.08, 0.15))+
  theme(legend.position = "none")+
  scale_fill_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))



plot_hab



```

### regressions
```{r, fig.width= 6, fig.height=4.5}
Figure_2 <- plot_grid(plot_nifh, plot_nifH_ab,  plot_hab,
                        align = "hv", labels="auto", ncol = 3) 
                        
plot(Figure_2)

ggsave("Figure_2.pdf", plot = Figure_2, width = 9, height = 3)
ggsave("Figure_2.jpeg", plot = Figure_2, width = 9, height = 3)
```

### full Model
### nifH

```{r}
mod_full <- lm(sqrt(N2_fixation) ~ sediment + corr_nifH + effN_nifh + effN_bac, data = FuncDat)

gg_diag(mod_full)

```


#### Results
```{r}

# Type II sum of squares testing the main effects (we don't include interactions)
car::Anova(mod_full, type = 2)

mod_full %>% glance %>% mutate_all(round, 2)

```


# Community composition

We have seen in the previous analysis that the nitrogen fixation rates cannot be well explained by either the abundance or the diversity of functional genes nor general bacterial diversity. However, the process rates differ in the different sediments.

An alternative hypothesis would be that process rates are driven by the presence or the combination of a few key species. As we don't have an *a priori* hypothesis abut **which** species could be important, this data analysis is exploratory. 

We use the DESeq2 package to look for differntially abundant OTUs that are:

+ Correlated to process rates, controling for sediments. 
+ Diffrentialy abundant between the sediments.

[Love, M. I., Huber, W., & Anders, S. (2014). Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2. Genome Biology, 15(12), 31.)](http://doi.org/10.1186/s13059-014-0550-8)

For the correlation of abundance with process rates with we test the hypthesis that process rate (PR) and the counts (C) are related as in

$$PR_{func} = 2^{(aC_{funcgen})} $$
$a$ is the log-fold change of counts with unit process rate. 

We also use the *rlogTransformation* implemented in the DESeq2 package to normalize the OTUtables and cluster the samples. 

## nifH

+ Reading in data & data wrangling.
```{r}
OTU_nifh <- read.table("https://ndownloader.figshare.com/files/10683388") 

# Fix sample names
rownames(OTU_nifh) <- sub("F", "", rownames(OTU_nifh))

# Exluding NA samples for functional data to match samles in OTU table
FuncDat <- FuncDat[!is.na(FuncDat$sample),]
rownames(FuncDat) <- FuncDat$sample

# read tree
TREE_nif <- read.tree("https://ndownloader.figshare.com/files/10683418")

#read cluster ID for each OTU

Cluster <- read.table("https://ndownloader.figshare.com/files/10683406", stringsAsFactors = FALSE)

Cluster <- 
Cluster %>% 
  mutate(main = sub("main cluster = ", "", main)) %>% 
  mutate(sub = sub("subcluster = ", "", sub)) %>% 
  select(-Zehr_group)

Cluster_m <- as.matrix(Cluster[,2:3])
rownames(Cluster_m) <- Cluster$names
  

```

+ We first create a phyloseq object with the otu table and the metadata (the phylogeny is not needed here).
+ We then transform the phyloseq object to a deseq2 object, telling it the experimental design. Here `~sediment + N2_fixation` means that we look for a correlation with N2_fixation, controling for sediment. 
+ We then test the hypothesis using the `DESeq`function. this function does three things: 
    + Estimates the size factors (correcting for sequence depth between samples).
    + Estimates dispersion (obtains dispersion estimates for Negative Binomial distributed data. See `?estimateDispersions` or the reference above for details. We use the the `parametric`option).
    + GLM fitting and Wald test (tests for significance of coefficients in a Negative Binomial GLM, using previously calculated sizeFactors and dispersion estimates - test for significant $a$ estimates in the formula above).
    + We also set `minReplicatesForReplace` to `Inf`. As we test of a continious variable, we don't have true biological replicates. 
    
### Correlation with N2_fixation



```{r}

nifH_ps <- phyloseq(otu_table(OTU_nifh, taxa_are_rows = F),
                   sample_data(FuncDat),
                   tax_table(Cluster_m))


nifH_d2 <- phyloseq_to_deseq2(nifH_ps, ~ sediment + sediment * N2_fixation)

Sigdiff_nif <- DESeq(nifH_d2, fitType = "parametric", test = "Wald",
                     minReplicatesForReplace = Inf, betaPrior = FALSE)


resultsNames(Sigdiff_nif)

res_nif <-  results(Sigdiff_nif,  
                    name = "N2_fixation",
                    cooksCutoff = FALSE, tidy =F) 

summary(res_nif)
```

+ With this design, we test for a correlation between N2_fixation rates and logfold change in OTU abundance - allowing for slopes and intercept to vary between sediments. 
+ No OTU shows a significant correlation

+ testing a correlation after agglomerating counts by subcluster
```{r}

nifH_ps_sub <- tax_glom(nifH_ps, taxrank="sub", NArm=TRUE, bad_empty=c(NA, "", " ", "\t"))

nifH_d2 <- phyloseq_to_deseq2(nifH_ps_sub, ~ sediment + sediment * N2_fixation)

Sigdiff_nif <- DESeq(nifH_d2, fitType = "parametric", test = "Wald",
                     minReplicatesForReplace = Inf, betaPrior = FALSE)


resultsNames(Sigdiff_nif)

res_nif <-  results(Sigdiff_nif,  
                    name = "N2_fixation",
                    cooksCutoff = FALSE, tidy =F) 

summary(res_nif)
```


+ testing a correlation after agglomerating counts by main cluster
```{r}

nifH_ps_main <- tax_glom(nifH_ps, taxrank="main", NArm=TRUE, bad_empty=c(NA, "", " ", "\t"))

nifH_d2 <- phyloseq_to_deseq2(nifH_ps_main, ~ sediment + sediment * N2_fixation)

Sigdiff_nif <- DESeq(nifH_d2, fitType = "parametric", test = "Wald",
                     minReplicatesForReplace = Inf, betaPrior = FALSE)


resultsNames(Sigdiff_nif)

res_nif <-  results(Sigdiff_nif,  
                    name = "N2_fixation",
                    cooksCutoff = FALSE, tidy =F) 

summary(res_nif)
    
```

### Differences between sediments

+ We cluster the samples based on the corrected counts.
+ To make the clustering "blind" to the experimental design, we enable the option `blind = T`.

```{r}

nif_cluster <- read.table("nif_cluster.txt", stringsAsFactors = FALSE) 

VST_nif <- assay(varianceStabilizingTransformation(Sigdiff_nif, blind = T))

VST_nif[VST_nif < 0 ]  <- 0

VST_nif <- VST_nif[ - c(which(rowSums(VST_nif) == 0)), ]

if(FALSE) {

  PS_nif <- phyloseq(otu_table(VST_nif, taxa_are_rows = T),
                    phy_tree(TREE_nif))

  Dist <- UniFrac(PS_nosz1, weighted = T)

  NMDS_nif <- metaMDS(Dist, autotransform = FALSE, trace = 0, distance = "bray")
} else {

  NMDS_nif <- metaMDS(t(VST_nif), autotransform = FALSE, trace = 0, distance = "bray")
  
}

stressplot(NMDS_nif)

# test if differneces in sediments are significant 

dist_nif <- metaMDSredist(NMDS_nif)

adonis(dist_nif ~ sediment, 
       data = FuncDat[ match( attr(dist_nif,"Labels"),FuncDat$sample),])

Stress_nif <- NMDS_nif$stress

NMDS_nifh <- NMDS_nif$points %>% 
  data.frame() %>% 
  rownames_to_column(var = "sample") %>% 
  mutate(sample = as.numeric(sample)) %>% 
  left_join(.,FuncDat) %>% 
  na.omit()

NMDS_plot_nifh <- ggplot(NMDS_nifh, aes(x = MDS1, y =MDS2, colour = sediment))+
  geom_point(size = 3)+
 # geom_label(data = filter(NMDS_nifh, sample %in% c(32:36, 42)), aes(label = sample), 
  #          nudge_x= 0.05, size = 6, alpha = 0.4)+
  theme_bw()+
  ggtitle("nifH gene composition - bray-curtis - rlogTransformed")+
  scale_colour_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))
  

NMDS_plot_nifh

# mantel test for correlation between community composition and denitrification rate
mantel(dist_nif, vegdist(as.matrix(FuncDat[ match( attr(dist_nif,"Labels"),FuncDat$sample),]$N2_fixation), dist = "euc"))
       



```


We see a clear separation of the samples by habitat and the permanova confirms that the differnces are significant (p = 0.001, r2 = 0.59)

## 16S 

+ Reading in data & data wrangling.

Read in the relevant files:
```{r, cache = TRUE}
OTU_bac <- read.table("https://ndownloader.figshare.com/files/10683412", header = TRUE, stringsAsFactors = FALSE)
TAX <- read.table("https://ndownloader.figshare.com/files/10683415",  header = TRUE, stringsAsFactors = FALSE)
TAX_m <- as.matrix(TAX)

dimnames(OTU_bac)[[1]] <- sub("C", "", dimnames(OTU_bac)[[1]])
```


As for `nifH`. Here `~sediment + sediment * N2_fixation` means that we look for a correlation with N2_fixation, allowing the slope and intercept to vary between sediments.

#### Correlation with nitrogen fixation
```{r}

ps_16S <- phyloseq(otu_table(OTU_bac, taxa_are_rows = F),
                   sample_data(FuncDat),
                   tax_table(TAX_m))


d2_16S_N2 <- phyloseq_to_deseq2(ps_16S, ~sediment + sediment*N2_fixation)

Sigdiff_16S_N2 <- DESeq(d2_16S_N2, fitType = "parametric", test = "Wald", minReplicatesForReplace = Inf)

resultsNames(Sigdiff_16S_N2)

res_nif <-  results(Sigdiff_16S_N2,  
                    name = "N2_fixation",
                    cooksCutoff = FALSE, tidy =F) 

summary(res_nif)

```

+ the abundance no (single) 16S OTU correlates with N2_fixation


+ testing after agglomeration to Familiy level
```{r}

ps_16S_family <- tax_glom(ps_16S, taxrank = "Family")


d2_16S_N2 <- phyloseq_to_deseq2(ps_16S_family, ~sediment + sediment*N2_fixation)

Sigdiff_16S_N2 <- DESeq(d2_16S_N2, fitType = "parametric", test = "Wald", minReplicatesForReplace = Inf)

resultsNames(Sigdiff_16S_N2)

res_nif <-  results(Sigdiff_16S_N2,  
                    name = "N2_fixation",
                    cooksCutoff = FALSE, tidy =F) 

summary(res_nif)

plotMA(res_nif)


sig_OTU <- res_nif %>% 
  as.data.frame() %>% 
  rownames_to_column(var = "OTU") %>% 
  filter(padj <= 0.1) 

sig_OTU

tax_table(ps_16S_family)[sig_OTU$OTU]

plotCounts(d2_16S_N2, gene=which.min(res_nif$padj), intgroup="N2_fixation", returnData = T, normalized =F) %>% 
  left_join(FuncDat_raw) %>% 
  ggplot(aes(x = count, y = N2_fixation, colour = sediment))+
  geom_smooth(se = F, method = "lm")+
  geom_point()
```

### Differences between sediments

+ We cluster the samples based on the corrected counts.
+ To make the clustering "blind" to the experimental design, we enable the option `blind = T`.

```{r}

VST_16S <- assay(varianceStabilizingTransformation(Sigdiff_16S_N2, blind = T))

VST_16S[VST_16S < 0 ]  <- 0

VST_16S <- VST_16S[ - c(which(rowSums(VST_16S) == 0)), ]

if( FALSE) {
  
  TREE_16S <- read.tree("16S_analysis/Tree_bac_um_oT.tre")
  dimnames(OTU_bac)[[1]] <- sub("C", "", dimnames(OTU_bac)[[1]])
  PS_16S <- phyloseq(otu_table(VST_16S, taxa_are_rows = T),
                    phy_tree(TREE_16S))

  Dist <- UniFrac(PS_16S, weighted = T)

  NMDS_16S <- metaMDS(Dist, autotransform = FALSE, trace = 0, distance = "bray")
} else {

  NMDS_16S <- metaMDS(t(VST_16S), autotransform = FALSE, trace = 0, distance = "bray")
  
}

stressplot(NMDS_16S)

dist_16S <- metaMDSredist(NMDS_16S)

adonis(dist_16S ~ sediment, 
       data = FuncDat[ match( attr(dist_16S,"Labels"),FuncDat$sample),])

Stress_16S <- NMDS_16S$stress

NMDS_16S <- NMDS_16S$points %>% 
  data.frame() %>% 
  rownames_to_column(var = "sample") %>% 
  mutate(sample = as.numeric(sample)) %>% 
  left_join(.,FuncDat) %>% 
  na.omit()

NMDS_plot_16S <- 
  ggplot(NMDS_16S, aes(x = MDS1, y =MDS2, colour = sediment))+
  geom_point(size = 3)+
#  geom_label(data = filter(NMDS_16S, sample %in% c(32:36, 42)), aes(label = sample),
 #           nudge_x= 0.05, size = 6, alpha = 0.4)+
  theme_bw()+
  ggtitle("16S composition - bray curtis")+
  scale_colour_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))
  

NMDS_plot_16S

# mantel test for correlation between community composition and denitrification rate
mantel(dist_16S, vegdist(as.matrix(FuncDat[ match( attr(dist_nif,"Labels"),FuncDat$sample),]$N2_fixation), dist = "euc"))
```



We see a separation of the samples by habitat. The difference is significant (p = 0.001) and explains ~50 % of the variance (r^2 0.49)



## Summary

```{r}

nmds_clust <- 
NMDS_nifh %>% 
  mutate(gene = "nifh") %>% 
  rbind(mutate(NMDS_16S, gene = "16S")) %>% 
  mutate(gene = factor(gene, labels=c("16S rRNA", "nifH"))) %>% 
  ggplot(., aes(x = MDS1, y =MDS2))+
  geom_point(size = 4, colour = "darkgrey", alpha = 0.8, 
             aes(fill = sediment), shape = 21)+
  geom_text(data = data.frame(gene = c("16S rRNA", "nifH"),
                              x = 0.5, y = 0.8,
                              label = c(paste("stress: ",signif(Stress_16S,2)),
                                        paste("stress: ",signif(Stress_nif,2)))),
            aes(x = x, y = y, label = label))+
  facet_wrap(~gene, nrow = 1)+
  theme_bw()+
  ggtitle("NMDS clustering of 16S rRNA and nifH by habitat")+
  scale_fill_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))

ggsave("Figure_3.pdf", nmds_clust, width = 8, height = 4)
ggsave("Figure_3.jpg", nmds_clust, width = 8, height = 4)

nmds_clust 

```



# correlation simulation

```{r}

getBiCop <- function(n, rho, mar.fun=rnorm, x = NULL, ...) {
  if (!is.null(x)) {X1 <- x} else {X1 <- mar.fun(n, ...)}
  if (!is.null(x) & length(x) != n) warning("Variable x does not have the same length as n!")
  
  C <- matrix(rho, nrow = 2, ncol = 2)
  diag(C) <- 1
  
  C <- chol(C)
  
  X2 <- mar.fun(n)
  X <- cbind(X1,X2)
  
  # induce correlation (does not change X1)
  df <- X %*% C
  
  ## if desired: check results
  #all.equal(X1,X[,1])
  #cor(X)
  
  return(df)
}

set.seed(19234578)

Var1 <- rnorm(50, 0,1)
Var2 <- getBiCop(n = length(Var1), rho = 0.7, mar.fun = rnorm, x = Var1)[,2]
Var3 <- getBiCop(n = length(Var1), rho = 0.7, mar.fun = rnorm, x = Var2)[,2]
Var4 <- getBiCop(n = length(Var1), rho = 0.7, mar.fun = rnorm, x = Var3)[,2]
Var5 <- getBiCop(n = length(Var1), rho = 0.7, mar.fun = rnorm, x = Var4)[,2]

DF <- data.frame(Var1 = Var1,
                 Var2 = Var2,
                 Var3 = Var3,
                 Var4 = Var4,
                 Var5 = Var5)
        

pdf(file = "Figure_S5.pdf")
DF %>%   cor() %>%  corrplot(type = "lower", tl.col = "black", cl.ratio = 0.2, 
                      cl.length = 11, number.cex = 0.8, cl.cex = 1, tl.cex = 1, addCoef.col = "#323232", 
                      diag = F, method="ellipse",  cl.lim = c(0,1))

dev.off()

DF %>%   cor() %>%  corrplot(type = "lower", tl.col = "black", cl.ratio = 0.2, 
                      cl.length = 11, number.cex = 0.8, cl.cex = 1, tl.cex = 1, addCoef.col = "#323232", 
                      diag = F, method="ellipse",  cl.lim = c(0,1))

```




