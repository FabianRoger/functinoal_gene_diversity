---
title: "Data_analysis"
output:
  html_document:
    toc: yes
    toc_depth: 4
    toc_float: true
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, tidy = TRUE, highlight = TRUE)
```

```{r, echo = F, message=FALSE}
library(knitr)
library(tidyverse)
library(car)
library(broom)
library(gridExtra)
library(phyloseq)
library(DESeq2)
library(vegan)
#library(GGally)
#library(parallel)
```

# Experimental design:

![Experimental set-up](Experimental_layout.jpg)

In the experimental design, each diversity treatment consist of a meta-community ("big core") of four separate sediment communities ("small core") that correspond to the habitats.

For habitat level 1, each **metacommunity** is replicated 4 times for each habitat (resulting in 16 meta-communities in total).

Habitat level 2 to 4, consist of four replicated meta-communities each, and each meta-community contains 2x2 [level 2], (2x1 + 1x2) [level 3] and 4x1 [level 4] sediment communities ("small cores"), respectively. 

There are six missing samples.

+ Level 3 - replicate A - habitat cyano
+ Level 3 - replicate D - habitat silt
+ Level 4 - replicate A - habitat sand, cyano, ruppia & silt (entirely)

# Import and clean metadata and functional data

```{r, message = FALSE}
meta_full <- read.table("metadata_consens.txt")
```

Unfortunately a multidemnsional cluster analysis of the four independently sequences marker genes revealed that 6 samples (32-36 & 42) consistently cluster with the 'wrong' habitat which makes it likely that these samples have been misslabled (see nmds plot below). As we are unable to backtrace the source of the error, therefore we opt to exclude the samples from the analysis. 

One sample, sample 9, had too little DNA left to measure gene abundance via qPCR and at least for nosZ I&II the quality of the seqeuncing is doubtfull. We exclude it from the analysis. 

![nmds plot of all samples for the four genes](nmds_4_genes.png)

we exclude the following sample from the analysis

```{r}
meta_full %>% filter(season == "summer") %>% 
  filter(sample %in% c(32:36,42,9)) %>% 
  kable

meta <- meta_full %>% filter(season == "summer") %>% 
  filter(! sample %in% c(32:36,42,9)) %>% 
  na.omit()

write.table(meta, "meta_clean.txt")
```

read in and join remaining data
```{r}
N_func <- read_tsv("summer_habdiv_n2fix_deni_new.txt")
qPCR <- read_tsv("qPCR.txt")
Par_frct <- read.table("Fraction_Parallogues_nifh.txt", sep ="\t", header = T)
Chl_frct <- read.table("frct_Chl.txt")



FuncDat_raw <- meta %>% 
  filter(season == "summer") %>% 
  select(-season) %>% 
  mutate(habitat = ifelse(Level == 1, sediment, "mix")) %>% 
  select(-habitat) %>% 
  left_join(N_func) %>% 
  left_join(qPCR) %>% 
  left_join(Par_frct) %>% 
  left_join(Chl_frct) %>% 
  arrange(Level, replicate, sediment)

kable(head(FuncDat_raw))
```


Both the 16S and the nifH primer picked up more than the target genes.

+ The nifh primers picked up a sizable fraction (`r paste(paste(round(min(FuncDat$frct.par, na.rm = T)*100),  round(max(FuncDat$frct.par, na.rm = T)*100), sep = " - "), "%")`) of nifh - parallogues, i.e. close relatives to nifh sequences that are not involved in nitrogen fixation. 

+ The 16S primers picked up chloroplast sequences (`r paste(paste(round(min(FuncDat$frct_Chl, na.rm = T)),  round(max(FuncDat$frct_Chl, na.rm = T)), sep = " - "), "%")`).

As we used the same primers in the qPCR assays, we need to account for that. We therefore correct each sample for the % of non-target sequences in different runs. This correction is not perfect as 1) we don't know the variability of the % of target sequences picked up in different runs, 2) as the qPCR conditions varied slightly from the pcr conditions for library preparation and 3) as the sequence count from amplicon sequencing is only roughly quantitative.

```{r}

FuncDat <- FuncDat_raw %>% 
  mutate(nifH = nifH * (1 - frct.par)) %>% 
  mutate(`16S` = `16S` * ((100 - frct_Chl) / 100))

```

# Habitat diveristy versus process rates

```{r}

Proc_Func <- N_func %>% 
  inner_join(filter(meta_full, season == "summer")) %>% 
  select(-sample, -season) %>% 
  gather(Process, Rate, -Level, -sediment, - replicate, -weight) %>%
  mutate(weight = ifelse(Level == 1, weight*4, ifelse(Level == 2, weight*2, weight))) %>% 
  group_by(Level, replicate, Process) %>% 
  mutate(Rate = ifelse(Level == 1, Rate*4, weighted.mean(Rate, weight)*4)) %>%
  group_by(Level, replicate, Process, Rate) %>% 
  summarize(sand = ifelse("sand" %in% sediment, weight[which(sediment == "sand")], 0),
            silt = ifelse("silt" %in% sediment, weight[which(sediment == "silt")], 0),
            cyano = ifelse("cyano" %in% sediment, weight[which(sediment == "cyano")], 0),
            ruppia = ifelse("ruppia" %in% sediment, weight[which(sediment == "ruppia")], 0))
  


Rate_habdiv_plot <- ggplot(Proc_Func, aes()) +
  geom_point(data = filter(Proc_Func, sand > 0), 
             aes(x = Level - 0.15, y = Rate, fill = "sand", size = sand), shape = 21, alpha = 0.7)+
  geom_point(data = filter(Proc_Func, cyano > 0), 
             aes(x = Level - 0.05, y = Rate, fill = "cyano", size = cyano), shape = 21, alpha = 0.7)+
  geom_point(data = filter(Proc_Func, ruppia > 0), 
             aes(x = Level + 0.05, y = Rate, fill = "ruppia", size = ruppia), shape = 21, alpha = 0.7)+
  geom_point(data = filter(Proc_Func, silt > 0), 
             aes(x = Level + 0.15, y = Rate, fill = "silt", size = silt), shape = 21, alpha = 0.7)+
  facet_wrap(~Process, scales = "free_y") +
  scale_fill_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"), guide_legend(title = "Habitats"))+
  scale_size_area(limits = c(1,4), guide = FALSE)+
  geom_smooth(data = Proc_Func, aes(x = Level, y = Rate, group =1), 
              method = "lm", se = F, size = 0.4, colour = "#003366")+
  labs(x = "Habitat diversity", y = "Process rate")+
  theme_bw()+
  theme(legend.position = "bottom")
  
  
Rate_habdiv_plot

ggsave("Rate_habdiv_plot.pdf", plot = Rate_habdiv_plot, width = 10, height = 5)
  


```


# Hypothesis 1

**Habitat diversity leads to increased bacterial diversity and to increased functional guild diversity (i.e. both more bacterial species in general but also a greater diversity of species carrying the genes for nitrogen fixation and denitrification respectively).**

To test this hypothesis we break it down into two questions:

## Hypothesis 1 a)

**Does functional gene diversity increase with overall bacterial diversity?**

We can test this hypothesis using the alpha diversity measurements in the *small* cores, with all 50 data points. However, the measurements taken from small cores that came from the same *big* core are not independent and we need to account for that. Also, we measured *three* functional genes. Because the absolute values of the functional gene diversities are not (necessarily) comparable, we test each response variable separately. 
The (3) model tests the following hypotheses:

+ Functional gene diversity changes between habitats (the mean diversity differs between the habitats).
+ Functional gene diversity correlates with bacterial diversity (overall effect).
+ The relationship between bacterial diversity and functional gene diversity depend on the habitat (significant interaction effect).


### Import & reshape diveristy data

Note that I calculated three diversity metrics, *richness*, *effective number of species* and *effective number of phylogenetic equidistinct species*. Richness is a hard to estimate and therefore unreliable diversity metric and the ecological relevance of richness can be debated. Therefore I report it but exclude it from the data analysis. Effective number of species and phylogenetic diversity tend to be well correlated (see Diversity estimation), wherefore it is unlikely to yield very different results. Effective number of *species* (OTUs) is easier to interpret (number of species in an equally diverse but completely even community) than the phylogenetic diversity (number of unique "phylotypes", i.e. number of species in an equally phylodiverse community where all species have the same abundance and are equally unrelated to each other). To minimize the overall number of linear models, we present phylogentic diversity but only use the effective number of species in the data analysis. 



```{r}
DIV <- read.table("Diversity_estimations.txt")

DIVeffN <- DIV %>%
  select(-contains("S_")) %>% 
  select(-contains("y_")) %>% 
  select(-contains("phylo")) %>% 
  gather(func_gen, func_div, matches("_nifh|_nosz1|_nosz2")) %>% 
  na.omit() %>% 
  left_join(meta)
  

kable(head(DIVeffN))
```

### Test main effect of big cores

Note that the data structure could imply non-independence of the small cores that are grouped within each big core. To account for this we first test if there is a main effect of *big cores*.

```{r}
DIVeffN %>% 
  filter(Level > 1) %>%
  lm(func_div ~ func_gen * MC.ID, data=.) %>% 
  anova()
```

This should give us the [type I sum of squares](http://goanna.cs.rmit.edu.au/~fscholer/anova.php) and hence whether the big cores (MC.ID) have a significant effect *after* accounting for functional gene. I conclude that as neither the main effect nor the interaction is remotely significant we don't need to worry about non-independence of the functional gene diversity data and can safely pool the data. 

We now proceed to check whether the functional gene diversity is correlated to the overall bacterial diversity.

As the absolute diversity values of three functional genes are not necessarily comparable, we model them separately (which also allows us to transform the data separately as appropriate).

### nifH
```{r, fig.width = 12, fig.height = 10}
mod_nifh <- lm(func_div ~  sediment * effN_bac, data = filter(DIVeffN, func_gen == "effN_nifh")) 

par(mfrow=c(3,3))
plot(mod_nifh)
hist(resid(mod_nifh))

shapiro.test(residuals(mod_nifh))
ncvTest(mod_nifh)
```
Here and for all subsequent models we use three methods to evaluate whether we meet the assumption for linear models (i.e. normality and heteroscedasticity (unequal variances) of residuals).

+ We inspect the diagnostic plots.
+ We test for non-normality using the Shapiro-Wilk test of normality (see `?shapiro.test`).
+ We test for unequal variance using the Score Test for Non-Constant Error Variance (Breusch-Pagan test). (see `?ncvTest`).

Here, the diagnostic plots look fine and both tests are non-significant. We proceed to interpret the model.

Also note that as our design is unbalanced (we have different number of observations for the different factor levels) we need to think about which type sum of squares to use. 

I adopt the following strategy: 

+ First we test for a significant interaction (default SS, type I).
+ If no significant interaction is found, we test the significance of the main effects with type II sum of squares. This tests the first main effect *over* the second main effect and vice versa, i.e. the effect for (A|B) and (B|A). It is equivalent to the test performed for the *second* main effect in type I sum of squares. 
+ If the interaction is significant (conventionally defined as p ≤ 0.05) we test the main effects with type III sum of squares, i.e. each main effect after accounting for the other main effect **and** the interaction, i.e. (A | B,A*B) & (B | A,A\*B). However, if the interaction is significant, the main effects are hard to interpret. 

#### Results
```{r}
# Type I sum of squares testing the interaction
anova(mod_nifh)

# Type II sum of squares testing the main effects
Anova(mod_nifh, type = 2)

mod_nifh %>% tidy %>% kable

mod_nifh %>% glance %>% kable

PRED <- predict(mod_nifh, type = "terms", interval = "pred")
Const <- attr(PRED$fit,"constant")

# Predict
PRED.df <-  data.frame(y = PRED$fit) %>% 
  mutate(y.effN_bac = y.effN_bac + Const) %>% 
  mutate(y.sediment = y.sediment + Const) %>% 
  mutate(y.sediment.effN_bac = y.sediment.effN_bac + y.effN_bac + y.sediment - Const) %>% 
  mutate(x = as.vector(DIVeffN[DIVeffN$func_gen == "effN_nifh", ]$effN_bac)) %>% 
  mutate(sediment = as.vector(DIVeffN[DIVeffN$func_gen == "effN_nifh", ]$sediment))

PRED.PI_lwr <-  data.frame(y = PRED$lwr) %>% 
  mutate(y.effN_bac_lwr = y.effN_bac + Const) %>% 
  mutate(y.sediment_lwr = y.sediment + Const) %>% 
  mutate(y.sediment.effN_bac_lwr = y.sediment.effN_bac + y.effN_bac_lwr + y.sediment_lwr - Const) %>% 
  mutate(x = as.vector(DIVeffN[DIVeffN$func_gen == "effN_nifh", ]$effN_bac)) %>% 
  mutate(sediment = as.vector(DIVeffN[DIVeffN$func_gen == "effN_nifh", ]$sediment)) %>% 
  select(-c(1:3))

PRED.PI_upr <-  data.frame(y = PRED$upr) %>% 
  mutate(y.effN_bac_upr = y.effN_bac + Const) %>% 
  mutate(y.sediment_upr = y.sediment + Const) %>% 
  mutate(y.sediment.effN_bac_upr = y.sediment.effN_bac + y.effN_bac_upr + y.sediment_upr - Const) %>% 
  mutate(x = as.vector(DIVeffN[DIVeffN$func_gen == "effN_nifh", ]$effN_bac)) %>% 
  mutate(sediment = as.vector(DIVeffN[DIVeffN$func_gen == "effN_nifh", ]$sediment)) %>% 
  select(-c(1:3)) %>% 
  left_join(PRED.PI_lwr)

plot_nifh <- DIVeffN %>% 
  filter(func_gen == "effN_nifh") %>% 
  ggplot()+
  geom_point(aes(x = effN_bac, y = func_div, fill = sediment), shape = 21, colour = "darkgrey", size = 2)+
  geom_line(data = PRED.df, aes(x = x, y = y.sediment.effN_bac, colour = sediment), 
            size = 0.5, alpha = 0.6, linetype = "dashed")+
  #geom_line(data = PRED.df, aes(x = x, y = y.effN_bac), colour = "black")+
  #geom_line(data = PRED.PI_upr, aes(x = x, y = y.effN_bac_lwr), linetype = "dashed")+
  #geom_line(data = PRED.PI_upr, aes(x = x, y = y.effN_bac_upr), linetype = "dashed")+
  theme_bw()+
  facet_wrap(~sediment)+
  labs(x = "effective number of bacterial otus", y = "effective number of nifH otus", title="nifH")+
  theme(legend.position = "bottom")+
  scale_colour_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))+
  scale_fill_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))

plot_nifh
```

+ Because the interaction is non-significant we go on and tested the main effects (type II sum of squares).

+ The main effect of 'sediment' is highly significant. The mean diversity of nifH genes changes with sediment with silt having the highest mean diversity and sand the lowest. 

+ The main effect of bacterial diversity is significant too, meaning that the number of nifH genes is positively correlated with the total bacterial community diversity.


### nosZ I

```{r, fig.width = 12, fig.height = 10}
mod_nosz1 <- lm(func_div ~ sediment * effN_bac, data = filter(DIVeffN, func_gen == "effN_nosz1")) 

par(mfrow=c(3,3))
plot(mod_nosz1)
hist(resid(mod_nosz1))

shapiro.test(residuals(mod_nosz1))
ncvTest(mod_nosz1)

```

The diagnostic plots don't look too bad but the tests suggest heteroscedasticity.

I try to log-transform the nosZ1 data.


```{r, fig.width = 12, fig.height = 10}
mod_nosz1_log <- lm(log(func_div, base = 10) ~  sediment * effN_bac, data = filter(DIVeffN, func_gen == "effN_nosz1")) 

par(mfrow=c(3,3))
plot(mod_nosz1_log)
hist(resid(mod_nosz1_log))

shapiro.test(residuals(mod_nosz1_log))
ncvTest(mod_nosz1_log)
```


The plots look okay now and the tests are unsignificant. The transformation was successful.

#### Results
```{r}
# Type I type of squares. Only for testing the interaction
anova(mod_nosz1_log)

# Type II sum of squares testing the main effects (as we have a significant interaction)
Anova(mod_nosz1_log, type = 2)

mod_nosz1_log %>% tidy %>%  mutate(estimate = 10^estimate) %>% kable

mod_nosz1_log %>% glance %>% kable

PRED <- predict(mod_nosz1_log, type = "terms")
Const <- attr(PRED,"constant")

# Predict
PRED.df <-  data.frame(y = PRED) %>% 
  mutate(y.sediment.effN_bac = 10^(y.sediment.effN_bac + y.effN_bac + y.sediment + Const)) %>% 
  mutate(y.effN_bac = 10 ^ (y.effN_bac + Const)) %>% 
  mutate(y.sediment = 10 ^ (y.sediment + Const)) %>% 
  mutate(x = as.vector(DIVeffN[DIVeffN$func_gen == "effN_nosz1", ]$effN_bac)) %>% 
  mutate(sediment = as.vector(DIVeffN[DIVeffN$func_gen == "effN_nosz1", ]$sediment))

plot_noszI <- DIVeffN %>% 
  filter(func_gen == "effN_nosz1") %>% 
  ggplot()+
  geom_point(aes(x = effN_bac, y = func_div, fill = sediment), shape = 21, colour = "darkgrey", size = 2)+
  geom_line(data = PRED.df, aes(x = x, y = y.sediment.effN_bac, colour = sediment),
            linetype = "dashed")+
  #geom_line(data = PRED.df, aes(x = x, y = y.effN_bac), colour = "black")+
  theme_bw()+
  facet_wrap(~sediment)+
  labs(x = "effective number of bacterial otus", y = "effective number of nosZ I otus", title="nosZ I")+
  theme(legend.position = "bottom")+
  scale_fill_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))+
  scale_colour_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))

plot_noszI

```

+ There is no significant interaction. We test the main effects with type II sum of squares.
+ Mean diversity of nosZ I OTUs changes with sediment. Highest diversity is observed in silt and cyano, lowest diversity in sand and ruppia.
+ There is no effect of the effective number of total bacterial otus on the effective number of nosZ I OTUs


### nosZ II

```{r, fig.width = 12, fig.height = 10}
mod_nosz2 <- lm(func_div ~ sediment * effN_bac, data = filter(DIVeffN, func_gen == "effN_nosz2")) 

par(mfrow=c(3,3))
plot(mod_nosz2)
hist(resid(mod_nosz2))

shapiro.test(residuals(mod_nosz2))
ncvTest(mod_nosz2)


```

The diagnostic plots and the tests look fine.

#### Results
```{r}

anova(mod_nosz2)
Anova(mod_nosz2, type = 3)

mod_nosz2 %>% tidy %>%  kable

mod_nosz2 %>% glance %>% kable

PRED <- predict(mod_nosz2, type = "terms")
Const <- attr(PRED,"constant")

# Predict
PRED.df <-  data.frame(y = PRED) %>% 
  mutate(y.effN_bac = y.effN_bac + Const) %>% 
  mutate(y.sediment = y.sediment + Const) %>% 
  mutate(y.sediment.effN_bac = y.sediment.effN_bac + y.effN_bac + y.sediment - Const) %>% 
  mutate(x = as.vector(DIVeffN[DIVeffN$func_gen == "effN_nosz2", ]$effN_bac)) %>% 
  mutate(sediment = as.vector(DIVeffN[DIVeffN$func_gen == "effN_nosz2", ]$sediment))

plot_noszII <- DIVeffN %>% 
  filter(func_gen == "effN_nosz2") %>% 
  ggplot()+
  geom_point(aes(x = effN_bac, y = func_div, fill = sediment), shape = 21, colour = "darkgrey", size = 2)+
  geom_line(data = PRED.df, aes(x = x, y = y.sediment.effN_bac, colour = sediment),
            linetype = "dashed")+
  #geom_line(data = PRED.df, aes(x = x, y = y.effN_bac), colour = "black")+
  facet_wrap(~sediment)+
  theme_bw()+
  labs(x = "effective number of bacterial otus", y = "effective number of nosZ II otus", title="nosZ II")+
  theme(legend.position = "bottom")+
  scale_fill_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))+
  scale_colour_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))

plot_noszII
```

+ There is a significant interaction. The relationship between bacterial diversity and nosZ II OTU diversity depends on the sediment. It is strongest in sediments cyano and sand and flat in ruppia silt. The main effects must therefore be interpreted with care.

+ There is a strong significant positive relationship between the effective number of nosZ II OTUs and the overall bacterial diversity after accounting for the main effect of sediment and the interaction.

+ There is a significant difference between the sediments.


## Hypothesis 1 b)

**Habitat diversity leads to increased bacterial gamma diversity and to increased functional guild gamma diversity.**

*Gamma diversity* has been calculated on the level of the large cores, comprising 4 different small cores with 1 - 4 different habitats. Note that for level 1 alpha and gamma diversity are the same (only 1 pooled sample was taken for each identical habitat). For level 3, the habitats were weighted by their abundance (i.e. the habitat that was present twice was weighted double).

+ We take habitat as categorical variable.
+ We exclude two level 3 cores and two level 4 cores with missing samples.
+ We test each functional gene separately.
+ We use effective number of species as diversity metric.

The first possibility how habitat diversity could impact functional gene diversity is through it's impact on bacterial 16S diversity. We can hence test if 16S gamma diversity is at all related to habitat diversity. 

### Reshape diveristy data


```{r}

DIVeffN_y <- DIV %>%
  select( Level, MC.ID, contains("y_")) %>% 
  select( - matches("_S_|_phylo")) %>% 
  distinct(.keep_all = TRUE) %>% 
  gather(func_gen, y_func_div, matches("_nifh|_nosz1|_nosz2")) %>% 
  na.omit() 
  

kable(head(DIVeffN_y))
```


### 16S gamma diversity

```{r, fig.width = 12, fig.height = 10}

mod_16S <- lm(y_effN_bac ~ Level, data = filter(DIVeffN_y, func_gen == "y_effN_nosz1")) 

par(mfrow=c(3,3))
plot(mod_16S)
hist(resid(mod_16S))

shapiro.test(residuals(mod_16S))
ncvTest(mod_16S)

```

The plots don't look great but the test are unsignificant and there is little we can do by transforming the data in this case.

#### Results
```{r}
anova(mod_16S)

PRED <- 
  data.frame(y = predict(mod_16S)) %>% 
  mutate(Level = as.vector(DIVeffN_y[DIVeffN_y$func_gen == "y_effN_nosz2", ]$Level))

plot_16S_y <- DIVeffN_y %>% 
  filter(func_gen == "y_effN_nosz2") %>% 
  ggplot(aes(x = Level, y = y_effN_bac, colour = as.factor(Level)))+
  geom_point()+
  geom_line(data = PRED, aes(x = Level, y = y, group = 1), colour = "black", size = 0.3)+
  theme_bw()+
  labs(y = "bacterial gamma diversity", x = "Level", title="16S")+
  theme(legend.position = "bottom")

plot_16S_y
```

+ Average bacterial gamma diversity increases with habitat diveristy, but the evidence is week. While the trend is clear from the plot, statistical signifcance is week, likely because we had to 4 metacommunities with high habitat diversity.

We proceed to test if functional gene gamma diversity is related to bacterial gamma diversity and / or habitat diversity level. 

### nifH

```{r, fig.width = 12, fig.height = 10}

mod_nifh_y <- lm(y_func_div ~ y_effN_bac * Level, data = filter(DIVeffN_y, func_gen == "y_effN_nifh")) 

par(mfrow=c(3,3))
plot(mod_nifh_y)
hist(resid(mod_nifh_y))

shapiro.test(residuals(mod_nifh_y))
ncvTest(mod_nifh_y)
```

The diagnostic plots and tests look fine.

#### Results
```{r}

anova(mod_nifh_y)

Anova(mod_nifh_y, type=2)

mod_nifh_y %>% tidy %>%  kable

mod_nifh_y %>% glance %>% kable

# Predict
PRED <- predict(mod_nifh_y, type = "terms")
Const <- attr(PRED,"constant")

PRED.df <-  data.frame(y = PRED) %>% 
  mutate(y.y_effN_bac.Level = y.y_effN_bac.Level + y.Level + y.y_effN_bac + Const) %>% 
  mutate(y.y_effN_bac = y.y_effN_bac + Const) %>% 
  mutate(y.Level = y.Level + Const) %>% 
  mutate(x = as.vector(DIVeffN_y[DIVeffN_y$func_gen == "y_effN_nifh", ]$y_effN_bac)) %>% 
  mutate(Level = as.vector(DIVeffN_y[DIVeffN_y$func_gen == "y_effN_nifh", ]$Level))

plot_nifh_y <- DIVeffN_y %>% 
  filter(func_gen == "y_effN_nifh") %>% 
  ggplot(aes(x = y_effN_bac, y = y_func_div, colour = as.factor(Level)))+
  geom_point()+
  #geom_line(data = PRED.df, aes(x = x, y = y.y_effN_bac.Level), linetype = "dashed")+
  geom_line(data = PRED.df, aes(x = x, y = y.y_effN_bac), colour = "black")+
  theme_bw()+
  labs(x = "bacterial gamma diversity", y = "nifH gamma diveristy", title="nifH")+
  theme(legend.position = "bottom")



plot_nifh_y
```

+ There is a positive effect of habitat diversity level on nifH gamma diversity but no effect of bacterial gamma diversity (after accounting for habitat diversity levels). 


### nosZ I

```{r, fig.width = 12, fig.height = 10}

mod_nosz1_y <- lm(y_func_div ~  y_effN_bac * Level, data = filter(DIVeffN_y, func_gen == "y_effN_nosz1")) 

par(mfrow=c(3,3))
plot(mod_nosz1_y)
hist(resid(mod_nosz1_y))

shapiro.test(residuals(mod_nosz1_y))
ncvTest(mod_nosz1_y)


```

The residuals deviate significantly from a normal distribution and the residuals show heteroscedasticity. We log transform the response variable.


```{r, fig.width = 12, fig.height = 10}

mod_nosz1_y_log <- lm(log(y_func_div, 10) ~  y_effN_bac * Level, data = filter(DIVeffN_y, func_gen == "y_effN_nosz1")) 

par(mfrow=c(3,3))
plot(mod_nosz1_y_log)
hist(resid(mod_nosz1_y_log))

shapiro.test(residuals(mod_nosz1_y_log))
ncvTest(mod_nosz1_y_log)

```

We fixed the non-normality. Variance doesn't look great but it's not too bad.

#### Results
```{r}

anova(mod_nosz1_y_log)
Anova(mod_nosz1_y_log, type = 2)


mod_nosz1_y_log %>% tidy %>%  mutate(estimate = 10^estimate) %>%  kable

mod_nosz1_y_log %>% glance %>% kable

# Predict
PRED <- predict(mod_nosz1_y_log, type = "terms")
Const <- attr(PRED,"constant")

PRED.df <-  data.frame(y = PRED) %>% 
  mutate(y.y_effN_bac.Level = 10^(y.y_effN_bac.Level + y.Level + y.y_effN_bac + Const)) %>% 
  mutate(y.y_effN_bac = 10^(y.y_effN_bac + Const)) %>% 
  mutate(y.Level = 10^(y.Level + Const)) %>% 
  mutate(x = as.vector(DIVeffN_y[DIVeffN_y$func_gen == "y_effN_nosz1", ]$y_effN_bac)) %>% 
  mutate(Level = as.vector(DIVeffN_y[DIVeffN_y$func_gen == "y_effN_nosz1", ]$Level))

plot_nosz1_y <- DIVeffN_y %>% 
  filter(func_gen == "y_effN_nosz1") %>% 
  ggplot(aes(x = y_effN_bac, y = y_func_div, colour = as.factor(Level)))+
  geom_point()+
  #geom_line(data = PRED.df, aes(x = x, y = y.y_effN_bac.Level), linetype = "dashed")+
  geom_line(data = PRED.df, aes(x = x, y = y.y_effN_bac), colour = "black")+
  theme_bw()+
  labs(x = "bacterial gamma diversity", y = "nosZ I gamma diveristy", title="nosZ I")+
  theme(legend.position = "bottom")



plot_nosz1_y
```

+ There is a positive effect of habitat diversity level on nosZ I gamma diversity but no effect of bacterial gamma diversity (after accounting for habitat diversity levels).


### nosZ II

```{r, fig.width = 12, fig.height = 10}

mod_nosz2_y <- lm(y_func_div ~  y_effN_bac * Level, data = filter(DIVeffN_y, func_gen == "y_effN_nosz2")) 

par(mfrow=c(3,3))
plot(mod_nosz2_y)
hist(resid(mod_nosz2_y))

shapiro.test(residuals(mod_nosz2_y))
ncvTest(mod_nosz2_y)

```

The diagnostic plots and tests look fine.

#### Results
```{r}

anova(mod_nosz2_y)

Anova(mod_nosz2_y, type = 2)

mod_nosz2_y %>% tidy %>%  kable

mod_nosz2_y %>% glance %>% kable

# Predict
PRED <- predict(mod_nosz2_y, type = "terms")
Const <- attr(PRED,"constant")

PRED.df <-  data.frame(y = PRED) %>% 
  mutate(y.y_effN_bac.Level = y.y_effN_bac.Level + y.Level + y.y_effN_bac + Const) %>% 
  mutate(y.y_effN_bac = y.y_effN_bac + Const) %>% 
  mutate(y.Level = y.Level + Const) %>% 
  mutate(x = as.vector(DIVeffN_y[DIVeffN_y$func_gen == "y_effN_nosz2", ]$y_effN_bac)) %>% 
  mutate(Level = as.vector(DIVeffN_y[DIVeffN_y$func_gen == "y_effN_nosz2", ]$Level))

plot_nosz2_y <- DIVeffN_y %>% 
  filter(func_gen == "y_effN_nosz2") %>% 
  ggplot(aes(x = y_effN_bac, y = y_func_div, colour = as.factor(Level)))+
  geom_point()+
  #geom_line(data = PRED.df, aes(x = x, y = y.y_effN_bac.Level), linetype = "dashed")+
  geom_line(data = PRED.df, aes(x = x, y = y.y_effN_bac), colour = "black")+
  theme_bw()+
  labs(x = "bacterial gamma diversity", y = "nosZ II gamma diveristy", title="nosZ II")+
  theme(legend.position = "bottom")


plot_nosz2_y
```

+ nosZ II gamma diversity is significantly and positively correlated to bacterial gamma diversity as well to the habitat diveristy level.

## Summary Hypothesis I

### Functional gene diversity ~ bacterial diversity * sediment

+ Figures with predicted best fit lines.

```{r, fig.height=10, fig.width=10}
grid.arrange(plot_noszI, plot_noszII, plot_nifh, nrow=2)

```

+ p values

```{r}

data.frame(Factor = rownames(Anova(mod_nifh, type = 2))[1:3],
           nosZ.I = signif(Anova(mod_nosz1_log, type = 3)$`Pr(>F)`[2:4], 2),
           nosz.II = signif(Anova(mod_nosz2, type = 3)$`Pr(>F)`[2:4], 2),
            nifH = signif(Anova(mod_nifh, type = 2)$`Pr(>F)`[1:3], 2)) %>% kable( digits = 5)

```

### Bacterial gamma diversity ~ habitat diversity

```{r, echo = FALSE}
plot_16S_y
anova(mod_16S)
```

### Functional gene gamma diversity ~ bacterial diversity * habitat diversity

+ Figures with predicted best fit lines.

```{r, fig.height=10, fig.width=10}
grid.arrange(plot_nosz1_y, plot_nosz2_y, plot_nifh_y, nrow=2)

```

```{r}

data.frame(Factor = rownames(Anova(mod_nifh_y, type=2))[1:3],
           nosZ.I = signif(Anova(mod_nosz1_y_log, type = 2)$`Pr(>F)`[1:3], 2),
           nosz.II = signif(Anova(mod_nosz2_y, type = 2)$`Pr(>F)`[1:3], 2),
           nifH = signif(Anova(mod_nifh_y, type=2)$`Pr(>F)`[1:3], 2)) %>% kable( digits = 5)

```

### Verbal summary

**Hypothesis 1**
*Habitat diversity leads to increased bacterial diversity and to increased functional guild diversity*

__Hypothesis 1 a)__
*Functional gene diversity increases with overall bacterial diversity.*

Functional gene diversity (measured as effective number of functional gene OTUs) increases with bacterial diversity (measured as effective number of 16S OTUs) for nosZ II and nifH. The diveristy of nosZ I is unrelated to the bacterial diversity. Among nosZ II and nifH, the effect is stronger for noszII. However, for nosZ II the relationship depends on the sediment and is strong for cyano and sand but flat for ruppia and silt. For nifH the data are more noisy and no statistically significant interactions emmerges. 
For each functional gene, the diversity differs between the sediments. 

__Hypothesis 1 b)__
*Habitat diversity leads to increased bacterial gamma diversity and to increased functional guild gamma diversity.*

Bacterial gamma diversity increases with habitat diversity, but the effect is week. However, this conclusion gets further soupport from the distinct clustering of the samples by habitat - indicating distinct bacterial communities differentated by habitats. The same is true for the diveristy of all three function genes: functional gene gamma diveristy increases with habitat diversity in all three cases. 
After accounting for habitat diversity, functional gene diveristy increases with bacterial gamma diversity only for nosZ II. We find no significant interaction between habitat diversity and bacterial gamma diversity but have also only limited power to test for one. 

# Hypothesis 2

**Diversity of functional community explains process rates better than overall bacterial diversity and or abundance alone.**

Here we test the hypothesis that the two measured processes, denitrification and nitrogen fixation, are - in part - driven by the diversity of the *genetic potential* i.e. the effective number of the respective functional genes. The functional genes that we sequenced encode key components of key proteins necessary for the processes that we measured. A diversity of functional genes hence suggests a diversity of proteins that might operate under different optimal conditions. There is a potential for complementarity among the organisms bearing those proteins for using  microniches more efficiently. 

However we do not expect that process rates are governed solely by functional gene diversity and therefore need to include co-variates which we also suspect to influence the measured process rates. These co-variates are:

+ The abundance of functional gene copies in the community (as measure for *genetic potential*).
+ The habitat type (as agglomerative proxy measure for *environmental variables*).
+ The diversity of the whole bacterial community: general bacterial diversity could lead to complementary interactions that favor the bacteria in the functional guilde.


Before we proceed to run the model, we have to address the issue of possible non-independence of the measurements in each small core within each big core.

### Test main effect of MC.ID
```{r}
FuncDat %>% 
  select(N2_fixation, Denitrification, sample) %>% 
  left_join(DIV[1:3]) %>% 
  gather(func, rate, N2_fixation, Denitrification) %>% 
  filter(Level > 1) %>%
  lm(rate ~ func * MC.ID, data=.) %>% 
  anova()
```

There is no significant effect of *big core* on the process rates. Therefore we assume that we can pool the data.

### Reshape the data

```{r}
FuncDat_sub <- FuncDat %>% 
  select(sample, sediment, N2_fixation, Denitrification, nosZI, nosZII, nifH) %>% 
  left_join(select(DIV, sample, starts_with("effN"))) %>% 
  na.omit()

kable(head(FuncDat_sub))
```


### nifH

```{r, fig.width = 12, fig.height = 10}
mod_proc_nifh <- lm(N2_fixation ~ sediment + nifH + effN_nifh + effN_bac, data = FuncDat_sub)

par(mfrow=c(3,3))
plot(mod_proc_nifh)
hist(resid(mod_proc_nifh))

shapiro.test(residuals(mod_proc_nifh))
ncvTest(mod_proc_nifh)




```

The residuals are left-skewed. We try a sqrt transformation.

```{r, fig.width = 12, fig.height = 10}
mod_proc_nifh_sqrt <- lm( sqrt(N2_fixation) ~ sediment + nifH + effN_nifh + effN_bac, data = FuncDat_sub)

par(mfrow=c(3,3))
plot(mod_proc_nifh_sqrt)
hist(resid(mod_proc_nifh_sqrt))

shapiro.test(residuals(mod_proc_nifh_sqrt))
ncvTest(mod_proc_nifh_sqrt)


```

#### Results
```{r}

# Type II sum of squares testing the main effects (we don't include interactions)
Anova(mod_proc_nifh_sqrt, type = 2)

mod_proc_nifh_sqrt %>% tidy %>% kable

mod_proc_nifh_sqrt %>% glance %>% kable

# Predict
PRED <- predict(mod_proc_nifh_sqrt, type = "terms")
Const <- attr(PRED,"constant")

PRED.df <-  data.frame(PRED) %>%
  mutate(sediment = (sediment + Const)^2) %>% 
  mutate(nifH = (nifH + Const)^2) %>% 
  mutate(effN_nifh = (effN_nifh + Const)^2) %>% 
  mutate(effN_bac = (effN_bac + Const)^2) %>% 
  mutate(sample = as.vector(FuncDat_sub$sample)) %>% 
  gather(predictor, predicted, -sample)

plot_nifh_proc <- 
FuncDat_sub %>% 
  select(match(c("sample", "N2_fixation", unique(PRED.df$predictor)), colnames(.))) %>% 
  mutate(sediment = as.numeric(as.factor(sediment))) %>% 
  gather(predictor, raw, -sample, -N2_fixation) %>% 
  left_join(.,PRED.df) %>% 
  left_join(., select(FuncDat_sub, sample, sediment)) %>%
  mutate(predictor = factor(predictor, levels = c("nifH", "effN_nifh", "effN_bac", "sediment"),
                            labels = c("nifH abundance", "nifH diversity", "bacterial diversity", "sediment"))) %>% 
  ggplot(aes(x = raw, y = N2_fixation, colour = sediment))+
  geom_point()+
  geom_line(aes(x = raw, y = predicted, group = predictor), colour = "black", linetype = "dashed")+
  facet_wrap(~predictor, scales = "free_x")+
  theme_bw()+
  labs(x = "Predictor value", title="nifH - raw data and predicted main effects")+
  scale_colour_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))+
  theme(legend.position = "right")

plot_nifh_proc
```

The only significant main effect (after accounting for the other effects) is *sediment* , i.e. habitat. In genereal nitrogen fixation is highest in habitat cyano, followed by silt, sand and finaly ruppia (with one high outlier). 

### nosZ I 

```{r, fig.width = 12, fig.height = 10}
mod_proc_nosz1 <- lm(Denitrification ~ sediment + nosZI + effN_nosz1 + effN_bac, data = FuncDat_sub)

par(mfrow=c(3,3))
plot(mod_proc_nosz1)
hist(resid(mod_proc_nosz1))

shapiro.test(residuals(mod_proc_nosz1))
ncvTest(mod_proc_nosz1)


```

The residuals look normal but the variance doesn't look great. Transforming the data doesn't help though (I tried log10 and sqrt) and the variance doesn't look too bad. So we go with it.

#### Results
```{r}

# Type II sum of squares testing the main effects
Anova(mod_proc_nosz1, type = 2)

mod_proc_nosz1 %>% tidy %>% kable

mod_proc_nosz1 %>% glance %>% kable

# Predict
PRED <- predict(mod_proc_nosz1, type = "terms")
Const <- attr(PRED,"constant")

PRED.df <-  data.frame(PRED) %>%
  mutate(sediment = sediment + Const) %>% 
  mutate(nosZI = nosZI + Const) %>% 
  mutate(effN_nosz1 = effN_nosz1 + Const) %>% 
  mutate(effN_bac = effN_bac + Const) %>% 
  mutate(sample = as.vector(FuncDat_sub$sample)) %>% 
  gather(predictor, predicted, -sample)

plot_nosz1_proc <- 
FuncDat_sub %>% 
  select(match(c("sample", "Denitrification", unique(PRED.df$predictor)), colnames(.))) %>% 
  mutate(sediment = as.numeric(as.factor(sediment))) %>% 
  gather(predictor, raw, -sample, -Denitrification) %>% 
  left_join(.,PRED.df) %>% 
  left_join(., select(FuncDat_sub, sample, sediment)) %>%
  mutate(predictor = factor(predictor, levels = c("nosZI", "effN_nosz1", "effN_bac", "sediment"),
                            labels = c("nosZ I abundance", "nosZ I diversity", "bacterial diversity", "sediment"))) %>% 
  ggplot(aes(x = raw, y = Denitrification, colour = sediment))+
  geom_point()+
  geom_line(aes(x = raw, y = predicted, group = predictor), colour = "black", linetype = "dashed")+
  facet_wrap(~predictor, scales = "free_x")+
  theme_bw()+
  labs(x = "Predictor value", title="nosZ I - raw data and predicted main effects")+
  scale_colour_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))+
  theme(legend.position = "right")

plot_nosz1_proc
```

Denitrification rates are unrelated to nosZ I abundance or diversity as well as to bacterial diversity or type of sediment (although there seems to be trend for lower denitrification in habitat ruppia with no dofferences among the other habitats).

### nosZ II

```{r, fig.width = 12, fig.height = 10}
mod_proc_nosz2 <- lm(Denitrification ~ sediment + nosZII + effN_nosz2 + effN_bac, data = FuncDat_sub)

par(mfrow=c(3,3))
plot(mod_proc_nosz2)
hist(resid(mod_proc_nosz2))

shapiro.test(residuals(mod_proc_nosz2))
ncvTest(mod_proc_nosz2)

```

#### Results
```{r}

# Type II sum of squares testing the main effects
Anova(mod_proc_nosz2, type = 2)

# Proportion of variance explained by main factors 
Anova(mod_proc_nosz2, type = 2)$`Sum Sq`/sum(Anova(mod_proc_nosz2, type = 2)$`Sum Sq`)*100

mod_proc_nosz2 %>% tidy %>% kable

mod_proc_nosz2 %>% glance %>% kable

# Predict
PRED <- predict(mod_proc_nosz2, type = "terms")
Const <- attr(PRED,"constant")

PRED.df <-  data.frame(PRED) %>%
  mutate(sediment = sediment + Const) %>% 
  mutate(nosZII = nosZII + Const) %>% 
  mutate(effN_nosz2 = effN_nosz2 + Const) %>% 
  mutate(effN_bac = effN_bac + Const) %>% 
  mutate(sample = as.vector(FuncDat_sub$sample)) %>% 
  gather(predictor, predicted, -sample)

plot_nosz2_proc <- 
FuncDat_sub %>% 
  select(match(c("sample", "Denitrification", unique(PRED.df$predictor)), colnames(.))) %>% 
  mutate(sediment = as.numeric(as.factor(sediment))) %>% 
  gather(predictor, raw, -sample, -Denitrification) %>% 
  left_join(.,PRED.df) %>% 
  left_join(., select(FuncDat_sub, sample, sediment)) %>%
  mutate(predictor = factor(predictor, levels = c("nosZII", "effN_nosz2", "effN_bac", "sediment"),
                            labels = c("nosZ II abundance", "nosZ II diversity", "bacterial diversity", "sediment"))) %>% 
  ggplot(aes(x = raw, y = Denitrification, colour = sediment))+
  geom_point()+
  geom_line(aes(x = raw, y = predicted, group = predictor), colour = "black", linetype = "dashed")+
  facet_wrap(~predictor, scales = "free_x")+
  theme_bw()+
  labs(x = "Predictor value", title="nosZ II - raw data and predicted main effects")+
  scale_colour_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))+
  theme(legend.position = "right")

plot_nosz2_proc
```

There is statistical evidence that denitrification is related to noszII diversity, bacterial diversity and the sediment type, but not noszII abundance. However, denitrification is *negatively* correlated to noszII diveristy and *positively* correlated to bacterial diversity in genereal. Judging from the plot, the evidence for either seems week. 

Interstingly, here habitat is significant. The differnce with teh previous regression (using data on nosz I) is that we always check for the effect of the main affect *after* accounting for all other main effects. 

Yet, for all three cases the stastical soupport is rather week (p > 0.01).

## Summary Hypothesis 2

```{r, fig.height=10, fig.width=10}
grid.arrange(plot_nosz1_proc, plot_nosz2_proc, plot_nifh_proc, nrow=2)

```

+ p values

```{r}

data.frame(Factor = c("Sediment", "Func. gene abund.", "Func. gene div.", "Bac. div.", "Residuals"),
           nifH.p = signif(Anova(mod_proc_nifh_sqrt, type = 2)$`Pr(>F)`, 2),
           nifH.r = signif(Anova(mod_proc_nifh_sqrt, type = 2)$`Sum Sq`/sum(Anova(mod_proc_nifh_sqrt, type = 2)$`Sum Sq`)*100,2),
           nosZ.I.p = signif(Anova(mod_proc_nosz1, type = 2)$`Pr(>F)`, 2),
           nosZ.I.r = signif(Anova(mod_proc_nosz1, type = 2)$`Sum Sq`/sum(Anova(mod_proc_nosz1, type = 2)$`Sum Sq`)*100,2),
           nosZ.II.p = signif(Anova(mod_proc_nosz2, type = 2)$`Pr(>F)`, 2),
           nosZ.II.r = signif(Anova(mod_proc_nosz2, type = 2)$`Sum Sq`/sum(Anova(mod_proc_nosz2, type = 2)$`Sum Sq`)*100,2)) %>% 
  mutate(nifH.adj = p.adjust(nifH.p, method = "holm")) %>% 
  mutate(nosZ.I.adj = p.adjust(nosZ.I.p, method = "holm")) %>% 
  mutate(nosZ.II.adj = p.adjust(nosZ.II.p, method = "holm")) %>% 
select(Factor,nifH.p,nifH.adj,nifH.r,nosZ.I.p,nosZ.I.adj,nosZ.I.r,nosZ.II.p, nosZ.II.r, nosZ.II.adj) %>% 
  kable
  

```


In the table above:

+ p-values are adjusted with the "holm" adjusting method *within* each model
+ `*.r` is the % total sum of squares for this factor

### Verbal summary

__Hypothesis 2__

*Diversity of functional community explains process rates better than overall bacterial diversity and or abundance alone.*

We find no support for this hypothesis. In general only habitat type has some credible relationship with process rate although the variation is large. It does explains 25 % of total variation for nitrogen fixation and 12 -18 % of total variation for denitrification. Contrary to our expectaions, functional gene abundance is not significantly correlated to procees rate in either of the cases. Functional gene diversity is weekly correlated in the case of denitrification with nosZ I. However, the relationship is negative and week, only explaining 11% of total variation. There is also a weekly significant positive relationship with bacterial diversity. 

# Community composition

We have seen in the previous analysis that the variation in process rates (nitrogen fixation and denitrification respectively) cannot be well explained by either the abundance or the diversity of functional genes nor general bacterial diversity. There is some tendency for the process rates being different in the different sediments but the effect is not very strong.

An alternative hypothesis would be that process rates are driven by the presence or the combination of a few key species. As we don't have an *a priori* hypothesis abut **which** species could be important, this data analysis is therefore exploratory. 

We use the DESeq2 package to look for differntially abundant OTUs that are:

+ Correlated to process rates, controling for sediments. 
+ Diffrentialy abundant between the sediments.

[Love, M. I., Huber, W., & Anders, S. (2014). Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2. Genome Biology, 15(12), 31.)](http://doi.org/10.1186/s13059-014-0550-8)

For the correlation of abundance with process rates with we test the hypthesis that process rate (PR) and the counts (C) are related as in

$$PR_{func} = 2^{(aC_{funcgen})} $$
$a$ is the log-fold change of counts with unit process rate. 

We also use the *rlogTransformation* implemented in the DESeq2 package to normalize the OTUtables and cluster the samples. 

## nifH

+ Reading in data & data wrangling.
```{r}
OTU_nifh <- read.table("OTU_nifh_clean.txt", sep = "\t", header = TRUE, stringsAsFactors = FALSE)

# Fix sample names
rownames(OTU_nifh) <- sub("F", "", rownames(OTU_nifh))

# Exluding na samples for functional data to match samles in OTU table
FuncDat <- FuncDat[!is.na(FuncDat$sample),]
rownames(FuncDat) <- FuncDat$sample

```

+ We first create a phyloseq object with the otu table and the metadata (the phylogeny is not needed here).
+ We then transform the phyloseq object to a deseq2 object, telling it the experimental design. Here `~sediment + N2_fixation` means that we look for a correlation with N2_fixation, controling for sediment. 
+ We then test the hypothesis using the `DESeq`function. this function does three things: 
    + Estimates the size factors (correcting for sequence depth between samples).
    + Estimates dispersion (obtains dispersion estimates for Negative Binomial distributed data. See `?estimateDispersions` or the reference above for details. We use the the `parametric`option).
    + GLM fitting and Wald test (tests for significance of coefficients in a Negative Binomial GLM, using previously calculated sizeFactors and dispersion estimates - test for significant $a$ estimates in the formula above).
    + We also set `minReplicatesForReplace` to `Inf`. As we test of a continious variable, we don't have true biological replicates. 
    
### Correlation with N2_fixation
```{r}
FuncDat <- mutate(FuncDat, sediment = ifelse(sample == 9, "cyano", sediment))
rownames(FuncDat) <- FuncDat$sample ### If sample 9 is re-assigned as sediment cyano (instead of silt) the significance goes away. 

nifH_ps <- phyloseq(otu_table(OTU_nifh, taxa_are_rows = F),
                    sample_data(FuncDat))

nifH_d2 <- phyloseq_to_deseq2(nifH_ps, ~sediment + N2_fixation)

Sigdiff_nif <- DESeq(nifH_d2, fitType = "parametric", test = "Wald", minReplicatesForReplace = Inf)

res_nif = results(Sigdiff_nif, name = "N2_fixation", cooksCutoff = FALSE)
alpha = 0.05

sigtab_nif <- res_nif[res_nif$padj < 0.05 & ! is.na(res_nif$padj),]
sigtab_nif

plotDispEsts(Sigdiff_nif, main = "dispersion estimations")
plotMA(res_nif, main = "shrunken log2fold changes with unit process rate change")

#VST_nifh <- assay(varianceStabilizingTransformation(Sigdiff_nif, blind = F))

't((VST_nifh[rownames(sigtab_nif),])) %>% 
  data.frame() %>% 
  rownames_to_column(var = "sample") %>% 
  mutate(sample = as.numeric(sample)) %>% 
  gather(OTU, LFC, -sample) %>% 
  left_join(FuncDat) %>% 
  ggplot(aes(y = N2_fixation, x = LFC, colour = sediment))+
  geom_point()+
 # geom_text(aes(label = sample))+ #driven by outlier sample 9!
  facet_wrap(~OTU)+
  stat_smooth(method ="lm", se = F, size = 0.5)+
  theme_bw()+ scale_colour_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))'

```

(+ If we account for differnce between the sediments, only the abundance of five OTUs is found to be significantly corelated with denitrification rates.)

** All significantly differnt OTUs that are found, are driven by sample 9. If sample 9 is re-assigned to cyano (which it likely is?), no OTUs correlate with denitrification rates after accounting for habitats. **

### Mantel test 

In the previous test we looked if the abundance (or rather log-fold-change in abundance) of any *single* OTU was correlated with the observed process rate. This was not the case. However, it is possible that a certain community composition is related to the process rate. If so, we can test the hypothesis that communities that are more alike, perform more similar in process rates than communities that are less alike - i.e. if there is a correlation between community distance and differnces in process rates. We can test this with a partial mantel test, correcting for habitat type. 

+ We use variance stabilized data to calculate the distance matrix. 
+ We set `blind = FALSE` to account for differnces between habitats (experimental design is taken into account for the variance stabilization).
+ We also enbale the optinon for outlier replacement to avoid undue influence of outliers on the distance estimations.

(Note, that as significance is assesed with a permutation test, the p-value has a lower limit (1/permutations).)

```{r}
nifH_d2_hab <- phyloseq_to_deseq2(nifH_ps, ~sediment)

Sigdiff_hab_nif <- DESeq(nifH_d2_hab, fitType = "parametric", test = "Wald", minReplicatesForReplace = 7, quiet = T)

VST_nif <- assay(varianceStabilizingTransformation(Sigdiff_hab_nif, blind = F))

MC_nif <- t(VST_nif[,order(as.numeric(colnames(VST_nif)))])

MC_nif <- MC_nif + abs(min(MC_nif))

dis.nifh <- vegdist(MC_nif, method = "jaccard")

FuncDat %>% 
  filter(sample %in% rownames(MC_nif)) %>%
  arrange(sample) %>% 
  adonis2(dis.nifh ~ sediment + N2_fixation, data = ., permutations = 9999)

```

**If Sample 9 is removed or re-assigned, there is no significant effect of N2_fixation (p = 0.7)**

### Differences between sediments

+ We cluster the samples based on the corrected counts.
+ To make the clustering "blind" to the experimental design, we enable the option `blind = T`.

```{r}

nif_cluster <- read.table("nif_cluster.txt", stringsAsFactors = FALSE) 

for (i in unique(nif_cluster$sub)){
   
}


VST_nif <- assay(varianceStabilizingTransformation(Sigdiff_hab_nif, blind = T))

VST_nif[VST_nif < 0 ]  <- 0

VST_nif <- VST_nif[ - c(which(rowSums(VST_nif) == 0)), ]

#VST_nif <- VST_nif[rownames(VST_nif) %in% nif_cluster[nif_cluster$sub != "subcluster = 1B",]$names,]

if(FALSE) {
  
  TREE_nif <- read.tree("TREE_nifh_um_oT.tre")
  PS_nif <- phyloseq(otu_table(VST_nif, taxa_are_rows = T),
                    phy_tree(TREE_nif))

  Dist <- UniFrac(PS_nosz1, weighted = T)

  NMDS_nif <- metaMDS(Dist, autotransform = FALSE, trace = 0, distance = "bray")
} else {

  NMDS_nif <- metaMDS(t(VST_nif), autotransform = FALSE, trace = 0, distance = "bray")
  
}

NMDS_nifh <- NMDS_nif$points %>% 
  data.frame() %>% 
  rownames_to_column(var = "sample") %>% 
  mutate(sample = as.numeric(sample)) %>% 
  left_join(.,FuncDat) %>% 
  na.omit()

NMDS_plot_nifh <- ggplot(NMDS_nifh, aes(x = MDS1, y =MDS2, colour = sediment))+
  geom_point(size = 3)+
 # geom_label(data = filter(NMDS_nifh, sample %in% c(32:36, 42)), aes(label = sample), 
  #          nudge_x= 0.05, size = 6, alpha = 0.4)+
  theme_bw()+
  ggtitle("nifH gene composition - bray-curtis - rlogTransformed")+
  scale_colour_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))
  

NMDS_plot_nifh

```

##Beta Null
```{r}
VST_nif_hab <- VST_nif[,colnames(VST_nif) %in% meta$sample]

VST_nif_hab <- 2^VST_nif_hab

VST_nif_hab <- VST_nif_hab[rowSums(VST_nif_hab) > 100,]
#VST_nif_hab <- VST_nif[rownames(VST_nif) %in% nif_cluster[nif_cluster$Zehr_group != 3, ]$names,]

M <- matrix(NA, nrow = nrow(VST_nif_hab), ncol = 4)
colnames(M) <- unique(meta$sediment)
rownames(M) <- rownames(VST_nif_hab)

for(i in unique(meta$sediment)){
  M[, i] <- rowMeans(VST_nif_hab[, colnames(VST_nif_hab) %in% meta[meta$sediment == i, ]$sample])
}

M <- t(apply(M,1,function(x) x/ sum(x)))
M <- na.omit(M)

ecodist <- vegdist(M, "bray")
  
library(ape)

TREE_nif <- read.tree("TREE_nifh_um_oT.tre")
TREE_nif <- drop.tip(TREE_nif, TREE_nif$tip.label[! TREE_nif$tip.label %in% rownames(M)]) 

pairwisePD <- cophenetic.phylo(TREE_nif)

DF <- data.frame(t(combn(rownames(M),2)), ecodist = as.numeric(ecodist), 
                 pairwisePD = as.numeric( as.dist(pairwisePD[rownames(M),rownames(M)] )))

PDplot_nifh <- DF %>% select(ecodist, pairwisePD) %>% 
  arrange(pairwisePD) %>% 
  mutate(bin = cut(pairwisePD, breaks = seq(min(pairwisePD), max(pairwisePD), len = 1000))) %>% 
  group_by(bin) %>% 
  mutate(n = n()) %>% 
  summarise_all( median) %>% 
  ggplot(aes(x = pairwisePD, y = ecodist, colour = sqrt(n)))+
  geom_point(size = 2)+
  stat_smooth( se= F)+
  theme_bw()+
  theme(legend.position = "none")+
  labs(title = "nifH")

PDplot_nifh
  
#cor(DF$ecodist, DF$pairwisePD)
```


We see a clear separation of the samples by habitat.

+ We also check whether we can identify OTUs that are signifcantly different between the four sediments.
+ Here, we do have true biological replicates, so we keep `minReplicatesForReplace` activated.

Because it turns out that we find a large number of differentially abundant OTUs between the sediments we try to focus on the most different cases. Therefore we:

+ Test for OTU's that have greater log-fold-changes then |2| (instead of 0). 
+ Set a rigurous p-value cutoff of the adjusted p-value of 0.001.

```{r}
# Get the results for all contratst and store them list
SedComb <- combn(c("cyano", "ruppia", "sand", "silt"), 2)

alpha = 0.001
LFC = 2

reslist_nif <- list()

par(mfrow=c(2,3))

for(i in 1:ncol(SedComb)) {
res = results(Sigdiff_hab_nif, contrast = c("sediment", SedComb[,i]), cooksCutoff = FALSE, lfcThreshold = LFC) 
plotMA(res, main = paste(SedComb[,i], collapse = " vs. "))
sigtab <- res[res$padj < alpha & !is.na(res$padj),]
reslist_nif[[i]] <- sigtab
}

names(reslist_nif) <- paste(SedComb[1, ], SedComb[2,], sep = "_")

diffOTUs_nif <- unique(unlist(lapply(reslist_nif, rownames)))

VST_nif[sample(diffOTUs_nif, 64),] %>% 
  data.frame() %>% 
  rownames_to_column(var = "OTU") %>% 
  gather(sample, abundance, -OTU) %>% 
  mutate(sample = as.numeric(gsub("X", "", sample))) %>% 
  left_join(meta) %>% 
  ggplot( aes(x = sediment, y = abundance, colour = sediment))+
  geom_point()+
  facet_wrap(~OTU)+
  theme_bw()+
  scale_colour_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))+
  labs(y = "~ log(2) of normalized counts")
```

Here I show normalized abundance values (assymptically  log2 of counts) for the OTUs that were identified as being most differntially abundant in at least 1 habitat - habitat comparision. Note that the normalized abundance values shown here is **not** what DESeq uses to check for differntial abundance (it rather models the raw counts taking into account sample depth and modelled dispersion).

I show this analysis only in case we choose to go further down this road (i.e. mapping the differntially abundant OTUs on the phylogeny).

## nosZ I

+ Reading in data & data wrangling.
```{r}
OTU_nosz1 <- read.table("nosz/nosZI_OTUtable_0.97_FR.txt", sep = "\t", header = TRUE, stringsAsFactors = FALSE)
dimnames(OTU_nosz1) <-  list(OTU_nosz1$OTU_ID, colnames(OTU_nosz1))
OTU_nosz1 <- t(as.matrix(OTU_nosz1[,-1 ]))
dimnames(OTU_nosz1)[[1]] <- sub("I", "", dimnames(OTU_nosz1)[[1]])
```


As for `nifH`. Here `~sediment + Denitrification` means that we look for a correlation with Denitrification, controling for sediment. 

    
### Correlation with denitrification
```{r}
nosz1_ps <- phyloseq(otu_table(OTU_nosz1, taxa_are_rows = F),
                    sample_data(FuncDat)) ### check!

nosz1_d2 <- phyloseq_to_deseq2(nosz1_ps, ~sediment + Denitrification)

Sigdiff_nosz1 <- DESeq(nosz1_d2, fitType = "parametric", test = "Wald", minReplicatesForReplace = Inf)

res_nosz1 = results(Sigdiff_nosz1, name = "Denitrification", cooksCutoff = FALSE)
alpha = 0.05

sigtab_nosz1 <-  res_nosz1[with(res_nosz1, order(padj, pvalue)),]
sigtab_nosz1

plotDispEsts(Sigdiff_nosz1, main = "dispersion estimations")
plotMA(res_nosz1, main = "shrunken log2fold changes with unit process rate change")
```

+ If we account for differnce between the sediments, no nosZ I-OTU is found to be positively (or negatively) correlated with the process rate.

### Mantel test 

In the previous test we looked if the abundance (or rather log-fold-change in abundance) of any *single* OTU was correlated with the observed process rate. This was not the case. However, it is possible that a certain community composition is related to the process rate. If so, we can test the hypothesis that communities that are more alike, perform more similar in process rates than communities that are less alike - i.e. if there is a correlation between community distance and differnces in process rates. We can test this with a partial mantel test, correcting for habitat type. 

+ We use variance stabilized data to calculate the distance matrix. 
+ We set `blind = FALSE` to account for differnces between habitats (experimental design is taken into account for the variance stabilization).
+ We also enbale the optinon for outlier replacement to avoid undue influence of outliers on the distance estimations.
+ Finally, to avoid undue influence of outliers in the clustering, we "cap" the maximum log-fold change to median + 5* sd.

(Note, that as significance is assesed with a permutation test, the p-value has a lower limit (1/permutations).)

```{r}
nosz1_d2_hab <- phyloseq_to_deseq2(nosz1_ps, ~sediment)

Sigdiff_hab_nosz1 <- DESeq(nosz1_d2_hab, fitType = "parametric", test = "Wald", minReplicatesForReplace = 7, quiet = T)

VST_nosz1 <- assay(varianceStabilizingTransformation(Sigdiff_hab_nosz1, blind = F))

MC_nosz1 <- t(VST_nosz1[,order(as.numeric(colnames(VST_nosz1)))])

# I add the absolute value of the minimum value of MC to each value to avoid negtive values. 
MC_nosz1 <- MC_nosz1+ abs(min(MC_nosz1))

dis.nosz1 <- vegdist(MC_nosz1, method = "jacc")

FuncDat %>% 
  filter(sample %in% rownames(MC_nosz1)) %>% 
  arrange(sample) %>% 
  adonis2(dis.nosz1 ~ sediment + Denitrification, data = ., permutations = 9999)

```


### Differences between sediments

+ We cluster the samples based on the corrected counts.
+ To make the clustering "blind" to the experimental design, we enable the option `blind = T`.

```{r}

VST_nosz1 <- assay(varianceStabilizingTransformation(Sigdiff_hab_nosz1, blind = T))

VST_nosz1[VST_nosz1 < 0 ]  <- 0

VST_nosz1 <- VST_nosz1[ - c(which(rowSums(VST_nosz1) == 0)), ]

if( FALSE) {
  
  TREE_nosz1 <- read.tree("nosz/nosZ_I_clean_FR.tree")
  PS_nosz1 <- phyloseq(otu_table(VST_nosz1, taxa_are_rows = T),
                    phy_tree(TREE_nosz1))

  Dist <- UniFrac(PS_nosz1, weighted = T)

  NMDS_nosz1 <- metaMDS(Dist, autotransform = FALSE, trace = 0, distance = "bray")
} else {

  NMDS_nosz1 <- metaMDS(t(VST_nosz1), autotransform = FALSE, trace = 0, distance = "bray")  
  
}



NMDS_nosz1 <- NMDS_nosz1$points %>% 
  data.frame() %>% 
  rownames_to_column(var = "sample") %>% 
  mutate(sample = as.numeric(sample)) %>% 
  left_join(.,FuncDat) %>% 
  na.omit()


NMDS_plot_nosz1 <- ggplot(NMDS_nosz1, aes(x = MDS1, y =MDS2, colour = sediment))+
  geom_point(size = 3)+
#  geom_label(data = filter(NMDS_nosz1, sample %in% c(32:36, 42)), aes(label = sample), 
#            nudge_x= 0.08, size = 6, alpha = 0.4)+
  theme_bw()+
  ggtitle("nosZ 1 gene composition - bray curtis - rlogTransformed")+
  scale_colour_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))
  

NMDS_plot_nosz1
```

We see a separation of the samples by habitat.

###Beta Null
```{r}
source("Beta_null_Chase_2011.R")
Beta_null_nosz1 <- raup_crick(t(VST_nosz1), plot_names_in_col1=FALSE, reps=99, classic_metric = T)

Beta_null_df_nosz1 <- data.frame(t(combn(rownames(t(VST_nosz1)),2)), as.numeric(Beta_null_nosz1))

names(Beta_null_df_nosz1) <- c("sample1", "sample2", "beta_0")

Beta_null_df_nosz1 <- 
  Beta_null_df_nosz1 %>% 
  mutate_at(vars(matches("sample")), as.numeric) %>% 
  left_join(select(meta, sample, sediment), by = c("sample1" = "sample")) %>% 
  rename(sediment = "sediment1") %>% 
  left_join(select(meta, sample, sediment), by = c("sample2" = "sample")) %>% 
  na.omit() %>% 
  mutate_at(vars(matches("sediment")), as.character) %>% 
  mutate(sed_comb = ifelse(sediment1 == sediment, sediment1, paste(sediment, sediment1,sep = "_"))) %>% 
  mutate(sed_comb = factor(sed_comb, levels = c(sort(unique(sed_comb)))))

ggplot(Beta_null_df_nosz1, aes(x = sed_comb, y = beta_0))+
  geom_point(position = position_jitter(width = 0.2), alpha=0.1, size = 2)+
  #geom_violin(fill = NA)+
  facet_wrap(~sediment, nrow = 1, scales = "free_x")+
  theme_bw()+
  theme(axis.text.x=element_text(angle = -90, hjust = 0))

```

```{r}
VST_nosz1_hab <- VST_nosz1[,colnames(VST_nosz1) %in% meta$sample]

VST_nosz1_hab <- 2^VST_nosz1_hab

VST_nosz1_hab <- VST_nosz1_hab[rowSums(VST_nosz1_hab) > 100,]

M <- matrix(NA, nrow = nrow(VST_nosz1_hab), ncol = 4)
colnames(M) <- unique(meta$sediment)
rownames(M) <- rownames(VST_nosz1_hab)

for(i in unique(meta$sediment)){
  M[, i] <- rowMeans(VST_nosz1_hab[, colnames(VST_nosz1_hab) %in% meta[meta$sediment == i, ]$sample])
}

M <- t(apply(M,1,function(x) x/ sum(x)))
M <- na.omit(M)

ecodist <- vegdist(M, "bray")
  
library(ape)

TREE_nosz1 <- read.tree("nosz/nosZ_I_clean_FR.tree")
TREE_nosz1 <- drop.tip(TREE_nosz1, TREE_nosz1$tip.label[! TREE_nosz1$tip.label %in% rownames(M)]) 

pairwisePD <- cophenetic.phylo(TREE_nosz1)

DF <- data.frame(t(combn(rownames(M),2)), ecodist = as.numeric(ecodist), 
                 pairwisePD = as.numeric( as.dist(pairwisePD[rownames(M),rownames(M)] )))

PDplot_nosz1 <- DF %>% select(ecodist, pairwisePD) %>% 
  arrange(pairwisePD) %>% 
  mutate(bin = cut(pairwisePD, breaks = seq(min(pairwisePD), max(pairwisePD), len = 1000))) %>% 
  group_by(bin) %>% 
  mutate(n = n()) %>% 
  summarise_all( median) %>% 
  ggplot(aes(x = pairwisePD, y = ecodist, colour = sqrt(n)))+
  geom_point(size = 2)+
  stat_smooth( se= F)+
  theme_bw()+
  theme(legend.position = "none")+
  labs(title = "nosz1")

PDplot_nosz1
  
cor(DF$ecodist, DF$pairwisePD)
```

+ We also check whether we can identify OTUs that are signifcantly different between the four sediments.
+ Here, we do have true biological replicates, so we keep `minReplicatesForReplace` activated.

Because it turns out that we find a large number of differntially abundant OTUs between the sediments we try to focus on the most different cases. Therefore we:

+ Test for OTU's that have greater log-fold-changes then |1| (instead of 0). 
+ Set a rigurous p-value cutoff of the adjusted p-value of 0.001.

```{r}
# Get the results for all contratst and store them list
SedComb <- combn(c("cyano", "ruppia", "sand", "silt"), 2)

alpha = 0.001
LFC = 2

reslist <- list()

par(mfrow=c(2,3))

for(i in 1:ncol(SedComb)) {
res = results(Sigdiff_hab_nosz1, contrast = c("sediment", SedComb[,i]), cooksCutoff = FALSE, lfcThreshold = LFC) 
plotMA(res, main = paste(SedComb[,i], collapse = " vs. "))
sigtab <- res[res$padj < alpha & !is.na(res$padj),]
reslist[[i]] <- sigtab
}

names(reslist) <- paste(SedComb[1, ], SedComb[2,], sep = "_")

diffOTUs <- unique(unlist(lapply(reslist, rownames)))

VST_nosz1[diffOTUs,] %>% 
  data.frame() %>% 
  rownames_to_column(var = "OTU") %>% 
  gather(sample, abundance, -OTU) %>% 
  mutate(sample = as.numeric(gsub("X", "", sample))) %>% 
  left_join(meta) %>% 
  ggplot( aes(x = sediment, y = abundance, colour = sediment))+
  geom_point()+
  facet_wrap(~OTU)+
  theme_bw()+
  scale_colour_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))+
  labs(y = "~ log(2) of normalized counts")
```

Here I show normalized abundance values (assymptically  log2 of counts) for the OTUs that were identified as being most differntially abundant in at least 1 habitat - habitat comparision. Note that the normalized abundance values shown here is **not** what DESeq uses to check for differntial abundance (it rather models the raw counts taking into account sample depth and modelled dispersion).

I show this analysis only in case we choose to go further down this road (i.e. maapping the differntially abundant OTUs on the phylogeny).

## nosZ II


+ Reading in data & data wrangling.
```{r}
OTU_nosz2 <- read.table("nosz/nosZII_OTUtable_0.97_FR.txt", sep = "\t", header = TRUE, stringsAsFactors = FALSE)
dimnames(OTU_nosz2) <-  list(OTU_nosz2$OTU_ID, colnames(OTU_nosz2))
OTU_nosz2 <- t(as.matrix(OTU_nosz2[,-1 ]))
dimnames(OTU_nosz2)[[1]] <- sub("II", "", dimnames(OTU_nosz2)[[1]])

```


As for `nifH`. Here `~sediment + Denitrification` means that we look for a correlation with Denitrification, controling for sediment. 

    
### Correlation with denitrification
```{r}
nosz2_ps <- phyloseq(otu_table(OTU_nosz2, taxa_are_rows = F),
                    sample_data(FuncDat))

nosz2_d2 <- phyloseq_to_deseq2(nosz2_ps, ~sediment + Denitrification)

Sigdiff_nosz2 <- DESeq(nosz2_d2, fitType = "parametric", test = "Wald", minReplicatesForReplace = Inf)

res_nosz2 = results(Sigdiff_nosz2, name = "Denitrification", cooksCutoff = FALSE)
alpha = 0.05

sigtab_nosz2 <-  res_nosz2[with(res_nosz2, order(padj, pvalue)),]
sigtab_nosz2[sigtab_nosz2$padj < 0.1 & ! is.na(sigtab_nosz2$padj),]

plotDispEsts(Sigdiff_nosz2, main = "dispersion estimations")
plotMA(res_nosz2, main = "shrunken log2fold changes with unit process rate change")


VST_nosz2 <- assay(varianceStabilizingTransformation(Sigdiff_nosz2, blind = F))

't((VST_nosz2[rownames(sigtab_nosz2[sigtab_nosz2$padj < 0.1 & ! is.na(sigtab_nosz2$padj),])[64:128],])) %>% 
  data.frame() %>% 
  rownames_to_column(var = "sample") %>% 
  mutate(sample = as.numeric(sample)) %>% 
  gather(OTU, LFC, -sample) %>% 
  left_join(FuncDat) %>% 
  ggplot(aes(y = Denitrification, x = LFC, colour = sediment, label = sample))+
  geom_point()+
  geom_text()+
 # geom_text(aes(label = sample))+ #driven by outlier sample 9!
  facet_wrap(~OTU)+
  stat_smooth(method ="lm", se = F, size = 0.5)+
  theme_bw()+ scale_colour_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))'

### All difference driven by Sample 9 #####

#select(FuncDat, sample, sediment, Denitrification) %>%  filter(sediment == "silt", Denitrification > 6)
```

** Here, too, all observed differences are driven soley by the differnce in abundance of OTUs in sample 9. Excluding this sample removes all signal. **

+ If we account for differnce between the sediments, no nosZ I-OTU is found to be positively (or negatively) correlated with the process rate.


### Mantel test 

In the previous test we looked if the abundance (or rather log-fold-change in abundance) of any *single* OTU was correlated with the observed process rate. This was not the case. However, it is possible that a certain community composition is related to the process rate. If so, we can test the hypothesis that communities that are more alike, perform more similar in process rates than communities that are less alike - i.e. if there is a correlation between community distance and differnces in process rates. We can test this with a partial mantel test, correcting for habitat type. 

+ We use variance stabilized data to calculate the distance matrix. 
+ We set `blind = FALSE` to account for differnces between habitats (experimental design is taken into account for the variance stabilization).
+ We also enbale the optinon for outlier replacement to avoid undue influence of outliers on the distance estimations.
+ Finally, to avoid undue influence of outliers in the clustering, we "cap" the maximum log-fold change to median + 5* sd.

(Note, that as significance is assesed with a permutation test, the p-value has a lower limit (1/permutations).)

```{r}
nosz2_d2_hab <- phyloseq_to_deseq2(nosz2_ps, ~sediment)

Sigdiff_hab_nosz2 <- DESeq(nosz2_d2_hab, fitType = "parametric", test = "Wald", minReplicatesForReplace = 7, quiet = T)

VST_nosz2 <- assay(varianceStabilizingTransformation(Sigdiff_hab_nosz2, blind = F))

MC_nosz2 <- t(VST_nosz2[,order(as.numeric(colnames(VST_nosz2)))])

# I add the absolute value of the minimum value of MC to each value to avoid negtive values. 
MC_nosz2 <- MC_nosz2 + abs(min(MC_nosz2))

dis.nosz2 <- vegdist(MC_nosz2, method = "bray")

FuncDat %>% 
  filter(sample %in% rownames(MC_nosz2)) %>% 
  arrange(sample) %>% 
  adonis2(dis.nosz2 ~ sediment + Denitrification, data = ., permutations = 9999)

```


### Differences between sediments

+ We cluster the samples based on the corrected counts.
+ To make the clustering "blind" to the experimental design, we enable the option `blind = T`.

```{r}

VST_nosz2 <- assay(varianceStabilizingTransformation(Sigdiff_hab_nosz2, blind = T))

VST_nosz2[VST_nosz2 < 0 ]  <- 0

VST_nosz2 <- VST_nosz2[ - c(which(rowSums(VST_nosz2) == 0)), ]

if( FALSE) {
  
  TREE_nosz1 <- read.tree("nosz/nosZ_II_clean_FR.tree")
  PS_nosz2 <- phyloseq(otu_table(VST_nosz2, taxa_are_rows = T),
                    phy_tree(TREE_nosz2))

  Dist <- UniFrac(PS_nosz2, weighted = T)

  NMDS_nosz2 <- metaMDS(Dist, autotransform = FALSE, trace = 0, distance = "bray")
} else {

  NMDS_nosz2 <- metaMDS(t(VST_nosz2), autotransform = FALSE, trace = 0, distance = "bray")
  
}



NMDS_nosz2 <- NMDS_nosz2$points %>% 
  data.frame() %>% 
  rownames_to_column(var = "sample") %>% 
  mutate(sample = as.numeric(sample)) %>% 
 # filter(sample != 9) %>% 
  left_join(.,FuncDat) %>% 
  na.omit()

NMDS_plot_nosz2 <- ggplot(NMDS_nosz2, aes(x = MDS1, y =MDS2, colour = sediment))+
  geom_point(size = 3)+
#  geom_label(data = filter(NMDS_nosz2, sample %in% c(32:36, 42)), aes(label = sample), 
 #           nudge_x= 0.1, size = 6, alpha = 0.4)+
  theme_bw()+
  ggtitle("nosZ 2 gene composition - bray curtis - rlogTransformed")+
  scale_colour_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))


NMDS_plot_nosz2
```

###Beta Null

```{r}
source("Beta_null_Chase_2011.R")
Beta_null_nosz2 <- raup_crick(t(VST_nosz2), plot_names_in_col1=FALSE, reps=99, classic_metric = T)

Beta_null_df_nosz2 <- data.frame(t(combn(rownames(t(VST_nosz2)),2)), as.numeric(Beta_null_nosz2))

Beta_null_nosz2_veg <- raupcrick(t(VST_nosz2), nsimul = 999,)
Beta_null_df_nosz2 <- data.frame(t(combn(rownames(t(VST_nosz2)),2)), as.numeric(Beta_null_nosz2_veg))

names(Beta_null_df_nosz2) <- c("sample1", "sample2", "beta_0")

Beta_null_df_nosz2 <- 
  Beta_null_df_nosz2 %>% 
  mutate_at(vars(matches("sample")), as.numeric) %>% 
  left_join(select(meta, sample, sediment), by = c("sample1" = "sample")) %>% 
  rename(sediment = "sediment1") %>% 
  left_join(select(meta, sample, sediment), by = c("sample2" = "sample")) %>% 
  na.omit() %>% 
  mutate_at(vars(matches("sediment")), as.character) %>% 
  mutate(sed_comb = ifelse(sediment1 == sediment, sediment1, paste(sediment, sediment1,sep = "_"))) %>% 
  mutate(sed_comb = factor(sed_comb, levels = c(sort(unique(sed_comb)))))

ggplot(Beta_null_df_nosz2, aes(x = sed_comb, y = beta_0))+
  geom_point(position = position_jitter(width = 0.2), alpha=0.1, size = 2)+
  #geom_violin(fill = NA)+
  facet_wrap(~sediment, nrow = 1, scales = "free_x")+
  theme_bw()+
  theme(axis.text.x=element_text(angle = -90, hjust = 0))

```

```{r}
function (comm, null = "r1", nsimul = 999, chase = FALSE, ...) 
{
    comm <- as.matrix(comm)
    comm <- ifelse(comm > 0, 1, 0)
    N <- nrow(comm)
    tri <- matrix(FALSE, N, N)
    tri <- row(tri) > col(tri)
    sol <- oecosimu(comm, function(x) tcrossprod(x)[tri], method = "c0_ind", 
        nsimul = 10)
    if (chase) 
        out <- 1 - sol$oecosimu$pval
    else out <- sol$oecosimu$pval
    attributes(out) <- list(class = c("raupcrick", "dist"), Size = N, 
        Labels = rownames(comm), call = match.call(), Diag = FALSE, 
        Upper = FALSE, method = "raupcrick")
    out
}
```

phylogenetic distance against niche distance 
```{r}
VST_nosz2_hab <- VST_nosz2[,colnames(VST_nosz2) %in% meta$sample]

VST_nosz2_hab <- 2^VST_nosz2_hab

VST_nosz2_hab <- VST_nosz2_hab[rowSums(VST_nosz2_hab) > 100,]

M <- matrix(NA, nrow = nrow(VST_nosz2_hab), ncol = 4)
colnames(M) <- unique(meta$sediment)
rownames(M) <- rownames(VST_nosz2_hab)


for(i in unique(meta$sediment)){
  M[, i] <- rowMeans(VST_nosz2_hab[, colnames(VST_nosz2_hab) %in% meta[meta$sediment == i, ]$sample])
}

M <- t(apply(M,1,function(x) x/ sum(x)))
M <- na.omit(M)

CV <- apply(M, 1, function(x) sd(x))

#M <- M[CV < 0.2,]

ecodist <- vegdist(M, "bray")


  
library(ape)

TREE_nosz2 <- read.tree("nosz/nosZ_II_clean_FR.tree")
TREE_nosz2 <- drop.tip(TREE_nosz2, TREE_nosz2$tip.label[! TREE_nosz2$tip.label %in% rownames(M)]) 

pairwisePD <- cophenetic.phylo(TREE_nosz2)

DF <- data.frame(t(combn(rownames(M),2)), ecodist = as.numeric(ecodist), 
                 pairwisePD = as.numeric( as.dist(pairwisePD[rownames(M),rownames(M)] )))

PDplot_nosz2 <- DF %>% select(ecodist, pairwisePD) %>% 
  arrange(pairwisePD) %>% 
  mutate(bin = cut(pairwisePD, breaks = seq(min(pairwisePD), max(pairwisePD), len = 1000))) %>% 
  group_by(bin) %>% 
  mutate(n = n()) %>% 
  summarise_all( median) %>% 
  ggplot(aes(x = pairwisePD, y = ecodist, colour = sqrt(n)))+
  geom_point(size = 2)+
  stat_smooth( se= F)+
  theme_bw()+
  theme(legend.position = "none")+
  labs(title = "nosz2")

PDplot_nosz2
  
#cor(DF$ecodist, DF$pairwisePD)
```

We see a separation of the samples by habitat.

+ We also check whether we can identify OTUs that are signifcantly different between the four sediments.
+ Here, we do have true biological replicates, so we keep `minReplicatesForReplace` activated.

Because it turns out that we find a large number of differntially abundant OTUs between the sediments we try to focus on the most different cases. Therefore we:

+ Test for OTU's that have greater log-fold-changes then |1| (instead of 0).
+ Set a rigurous p-value cutoff of the adjusted p-value of 0.001.

```{r}
# Get the results for all contratst and store them list
SedComb <- combn(c("cyano", "ruppia", "sand", "silt"), 2)

alpha = 0.001
LFC = 2

reslist_nosz2 <- list()

par(mfrow=c(2,3))

for(i in 1:ncol(SedComb)) {
res = results(Sigdiff_hab_nosz2, contrast = c("sediment", SedComb[,i]), cooksCutoff = FALSE, lfcThreshold = LFC) 
plotMA(res, main = paste(SedComb[,i], collapse = " vs. "))
sigtab <- res[res$padj < alpha & !is.na(res$padj),]
reslist_nosz2[[i]] <- sigtab
}

names(reslist_nosz2) <- paste(SedComb[1, ], SedComb[2,], sep = "_")

diffOTUs_nosz2 <- unique(unlist(lapply(reslist_nosz2, rownames)))

VST_nosz2[diffOTUs_nosz2,] %>% 
  data.frame() %>% 
  rownames_to_column(var = "OTU") %>% 
  gather(sample, abundance, -OTU) %>% 
  mutate(sample = as.numeric(gsub("X", "", sample))) %>% 
  left_join(meta) %>% 
  ggplot( aes(x = sediment, y = abundance, colour = sediment))+
  geom_point()+
  facet_wrap(~OTU)+
  theme_bw()+
  scale_colour_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))+
  labs(y = "~ log(2) of normalized counts")
```

Here I show normalized abundance values (assymptical log2 of counts) for the OTUs that were identified as being most differntially abundant in at least 1 habitat - habitat comparision. Note that the normalized abundance values shown here is **not** what DESeq uses to check for differntial abundance (it rather models the raw counts taking into account sample depth and modelled dispersion).

I show this analysis only in case we choose to go further down this road (i.e. mapping the differentially abundant OTUs on the phylogeny). 

## 16S

No functional gene correlated well with the process rates.

+ Reading in data & data wrangling.

Read in the relevant files:
```{r, cache = TRUE}
OTU_bac <- read.table("16S_analysis/OTU_bac_clean.txt", header = TRUE, stringsAsFactors = FALSE)

dimnames(OTU_bac)[[1]] <- sub("C", "", dimnames(OTU_bac)[[1]])
```


As for `nifH`. Here `~sediment + Denitrification` means that we look for a correlation with Denitrification, controling for sediment. 

### Denitrification

#### Correlation with denitrification
```{r}
ps_16S <- phyloseq(otu_table(OTU_bac, taxa_are_rows = F),
                    sample_data(FuncDat))

d2_16S_deni <- phyloseq_to_deseq2(ps_16S, ~sediment + Denitrification)

Sigdiff_16S <- DESeq(d2_16S_deni, fitType = "parametric", test = "Wald", minReplicatesForReplace = Inf)

res_16S = results(Sigdiff_16S, name = "Denitrification", cooksCutoff = FALSE)
alpha = 0.05

sigtab_16S <-  res_16S[with(res_16S, order(padj, pvalue)),]
sigtab_16S_deni <- sigtab_16S %>% data.frame %>% rownames_to_column(var = "OTU") %>% na.omit() %>% filter(padj <= 0.1)

sigtab_16S_deni

plotDispEsts(Sigdiff_16S, main = "dispersion estimations")
plotMA(res_16S, main = "shrunken log2fold changes with unit process rate change")


d2_16S_hab <- phyloseq_to_deseq2(ps_16S, ~sediment)

Sigdiff_16S_hab <- DESeq(d2_16S_hab, fitType = "parametric", test = "Wald", minReplicatesForReplace = 7, quiet = T)

VST_16S_hab <- assay(varianceStabilizingTransformation(Sigdiff_16S_hab, blind = F))

#t((VST_16S_hab[sigtab_16S_deni$OTU,])) %>% 
 # data.frame() %>% 
#  rownames_to_column(var = "sample") %>% 
#  mutate(sample = as.numeric(sample)) %>% 
#  gather(OTU, LFC, -sample) %>% 
#  left_join(FuncDat) %>% 
#  ggplot(aes(x = Denitrification, y = LFC, colour = sediment))+
#  geom_point()+
#  facet_wrap(~OTU)+
#  stat_smooth(method ="lm", se = F, size = 0.5)+
#  theme_bw()+ scale_colour_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))

```

After accounting for differnce between the sediments, the abundance of 4 OTUs is statistically significantly correlated to denitrification rates. However the plots show that this correlation is likely driven in all four cases by the high abundance of all four OTUs in the sample with the highest denitrifcation rates and there is no consistent relationship between abundance and process rate over the whole range of process rates. 

** Again all patterns are driven by sample 9. **

#### Mantel test 

In the previous test we looked if the abundance (or rather log-fold-change in abundance) of any *single* OTU was correlated with the observed process rate. This was not the case. However, it is possible that a certain community composition is related to the process rate. If so, we can test the hypothesis that communities that are more alike, perform more similar in process rates than communities that are less alike - i.e. if there is a correlation between community distance and differences in process rates. We can test this with a partial mantel test, correcting for habitat type. 

+ We use variance stabilized data to calculate the distance matrix. 
+ We set `blind = FALSE` to account for differences between habitats (experimental design is taken into account for the variance stabilization).
+ We also enable the option for outlier replacement to avoid undue influence of outliers on the distance estimations.
+ Finally, to avoid undue influence of outliers in the clustering, we "cap" the maximum log-fold change to median + 5* sd.

(Note, that as significance is assessed with a permutation test, the p-value has a lower limit (1/permutations).)

```{r}
MC_16S <- t(VST_16S_hab[,order(as.numeric(colnames(VST_16S_hab)))])

# I add the absolute value of the minimum value of MC to each value to avoid negtive values. 
MC_16S <- MC_16S + abs(min(MC_16S))

dis.16S <- vegdist(MC_16S, method = "bray")

FuncDat %>% 
  filter(sample %in% rownames(MC_16S)) %>% 
  arrange(sample) %>% 
  adonis2(dis.16S ~ sediment + Denitrification, data = ., permutations = 9999)

```

### Nitrogen fixation

#### Correlation with nitrogen fixation
```{r}
d2_16S_N2 <- phyloseq_to_deseq2(ps_16S, ~sediment + N2_fixation)

Sigdiff_16S_N2 <- DESeq(d2_16S_N2, fitType = "parametric", test = "Wald", minReplicatesForReplace = Inf)

res_16S_N2 = results(Sigdiff_16S_N2, name = "N2_fixation", cooksCutoff = TRUE)

sigtab_16S_N2 <-  res_16S_N2[with(res_16S_N2, order(padj, pvalue)),]
sigtab_16S_N2 <- sigtab_16S_N2 %>% data.frame %>% rownames_to_column(var = "OTU") %>% na.omit() %>% filter(padj <= 0.05)

sigtab_16S_N2 

plotDispEsts(Sigdiff_16S_N2, main = "dispersion estimations")
plotMA(res_16S_N2, main = "shrunken log2fold changes with unit process rate change")


d2_16S_hab <- phyloseq_to_deseq2(ps_16S, ~sediment)

#Sigdiff_16S_hab <- DESeq(d2_16S_hab, fitType = "parametric", test = "Wald", minReplicatesForReplace = 7, quiet = T)

'VST_16S_hab <- assay(varianceStabilizingTransformation(Sigdiff_16S_hab, blind = F))

t((VST_16S_hab[sigtab_16S_N2$OTU,])) %>% 
  data.frame() %>% 
  rownames_to_column(var = "sample") %>% 
  mutate(sample = as.numeric(sample)) %>% 
  gather(OTU, LFC, -sample) %>% 
  left_join(FuncDat) %>% 
  ggplot(aes(y = N2_fixation, x = LFC, colour = sediment))+
  geom_point()+
 # geom_text(aes(label = sample))+ #driven by outlier sample 9!
  facet_wrap(~OTU)+
  stat_smooth(method ="lm", se = F, size = 0.5)+
  theme_bw()+ scale_colour_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))'

```

After accounting for difference between the sediments, the abundance of 47 OTUs is statistically significantly correlated to denitrification rates. However, the plots show again that this correlation is likely driven in all four cases by the high abundance of all four OTUs in the sample with the highest N2 fixation rates and there is no consistent relationship between abundance and process rate over the whole range of process rates. 

#### Mantel test 

In the previous test we looked if the abundance (or rather log-fold-change in abundance) of any *single* OTU was correlated with the observed process rate. This was not the case. However, it is possible that a certain community composition is related to the process rate. If so, we can test the hypothesis that communities that are more alike, perform more similar in process rates than communities that are less alike - i.e. if there is a correlation between community distance and differences in process rates. We can test this with a partial mantel test, correcting for habitat type. 

+ We use variance stabilized data to calculate the distance matrix. 
+ We set `blind = FALSE` to account for differences between habitats (experimental design is taken into account for the variance stabilization).
+ We also enable the option for outlier replacement to avoid undue influence of outliers on the distance estimations.
+ Finally, to avoid undue influence of outliers in the clustering, we "cap" the maximum log-fold change to median + 5* sd.

(Note, that as significance is assessed with a permutation test, the p-value has a lower limit (1/permutations).)

```{r}

FuncDat %>% 
  filter(sample %in% rownames(MC_16S)) %>% 
  arrange(sample) %>% 
  adonis2(dis.16S ~ sediment + N2_fixation, data = ., permutations = 9999)

```


### Differences between sediments

+ We cluster the samples based on the corrected counts.
+ To make the clustering "blind" to the experimental design, we enable the option `blind = T`.

```{r}

VST_16S <- assay(varianceStabilizingTransformation(Sigdiff_16S_hab, blind = T))

VST_16S[VST_16S < 0 ]  <- 0

VST_16S <- VST_16S[ - c(which(rowSums(VST_16S) == 0)), ]

if( FALSE) {
  
  TREE_16S <- read.tree("16S_analysis/Tree_bac_um_oT.tre")
  dimnames(OTU_bac)[[1]] <- sub("C", "", dimnames(OTU_bac)[[1]])
  PS_16S <- phyloseq(otu_table(VST_16S, taxa_are_rows = T),
                    phy_tree(TREE_16S))

  Dist <- UniFrac(PS_16S, weighted = T)

  NMDS_16S <- metaMDS(Dist, autotransform = FALSE, trace = 0, distance = "bray")
} else {

  NMDS_16S <- metaMDS(t(VST_16S), autotransform = FALSE, trace = 0, distance = "bray")
  
}

NMDS_16S <- NMDS_16S$points %>% 
  data.frame() %>% 
  rownames_to_column(var = "sample") %>% 
  mutate(sample = as.numeric(sample)) %>% 
  left_join(.,FuncDat) %>% 
  na.omit()

NMDS_plot_16S <- 
  ggplot(NMDS_16S, aes(x = MDS1, y =MDS2, colour = sediment))+
  geom_point(size = 3)+
#  geom_label(data = filter(NMDS_16S, sample %in% c(32:36, 42)), aes(label = sample),
 #           nudge_x= 0.05, size = 6, alpha = 0.4)+
  theme_bw()+
  ggtitle("16S composition - bray curtis")+
  scale_colour_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))
  

NMDS_plot_16S
```


###Beta Null
```{r}
VST_16S_hab <- VST_16S[,colnames(VST_16S) %in% meta$sample]

VST_16S_hab <- 2^VST_16S_hab

VST_16S_hab <- VST_16S_hab[rowSums(VST_16S_hab) > 100,]

M <- matrix(NA, nrow = nrow(VST_16S_hab), ncol = 4)
colnames(M) <- unique(meta$sediment)
rownames(M) <- rownames(VST_16S_hab)

for(i in unique(meta$sediment)){
  M[, i] <- rowMeans(VST_16S_hab[, colnames(VST_16S_hab) %in% meta[meta$sediment == i, ]$sample])
}

M <- t(apply(M,1,function(x) x/ sum(x)))
M <- na.omit(M)

ecodist <- vegdist(M, "bray")
  
library(ape)

TREE_16S <- read.tree("16S_analysis/Tree_bac_um_oT.tre")
TREE_16S <- drop.tip(TREE_16S, TREE_16S$tip.label[! TREE_16S$tip.label %in% rownames(M)]) 

pairwisePD <- cophenetic.phylo(TREE_16S)

DF <- data.frame(t(combn(rownames(M),2)), ecodist = as.numeric(ecodist), 
                 pairwisePD = as.numeric( as.dist(pairwisePD[rownames(M),rownames(M)] )))

PDplot_16S <- DF %>% select(ecodist, pairwisePD) %>% 
  arrange(pairwisePD) %>% 
  mutate(bin = cut(pairwisePD, breaks = seq(min(pairwisePD), max(pairwisePD), len = 1000))) %>% 
  group_by(bin) %>% 
  mutate(n = n()) %>% 
  summarise_all( median) %>% 
  ggplot(aes(x = pairwisePD, y = ecodist, colour = n))+
  geom_point(size = 2)+
  stat_smooth( se= F)+
  theme_bw()+
  theme(legend.position = "none")+
  labs(title = "16S")

PDplot_16S
  
cor(DF$ecodist, DF$pairwisePD)
```

We see a separation of the samples by habitat.

+ We also check whether we can identify OTUs that are significantly different between the four sediments.
+ Here, we do have true biological replicates, so we keep `minReplicatesForReplace` activated.

Because it turns out that we find a large number of deferentially abundant OTUs between the sediments we try to focus on the most different cases. Therefore we:

+ Test for OTU's that have greater log-fold-changes then |2| (instead of 0). 
+ Set a rigorous p-value cutoff of the adjusted p-value of 0.001.

```{r}
# Get the results for all contratst and store them list
SedComb <- combn(c("cyano", "ruppia", "sand", "silt"), 2)

alpha = 0.001
LFC = 2

reslist <- list()

par(mfrow=c(2,3))

for(i in 1:ncol(SedComb)) {
res = results(Sigdiff_16S_hab, contrast = c("sediment", SedComb[,i]), cooksCutoff = FALSE, lfcThreshold = LFC) 
plotMA(res, main = paste(SedComb[,i], collapse = " vs. "))
sigtab <- res[res$padj < alpha & !is.na(res$padj),]
reslist[[i]] <- sigtab
}

names(reslist) <- paste(SedComb[1, ], SedComb[2,], sep = "_")

diffOTUs <- unique(unlist(lapply(reslist, rownames)))

VST_16S[diffOTUs,] %>% 
  data.frame() %>% 
  rownames_to_column(var = "OTU") %>% 
  gather(sample, abundance, -OTU) %>% 
  mutate(sample = as.numeric(gsub("X", "", sample))) %>% 
  left_join(meta) %>% 
  ggplot( aes(x = sediment, y = abundance, colour = sediment))+
  geom_point()+
  facet_wrap(~OTU)+
  theme_bw()+
  scale_colour_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))+
  labs(y = "~ log(2) of normalized counts")
```

Here I show normalized abundance values (asymptotically  log2 of counts) for the OTUs that were identified as being most deferentially abundant in at least 1 habitat - habitat comparison. Note that the normalized abundance values shown here is **not** what DESeq uses to check for differential abundance (it rather models the raw counts taking into account sample depth and modeled dispersion).

I show this analysis only in case we choose to go further down this road (i.e. mapping the deferentially abundant OTUs on the phylogeny).


## Summary

```{r, fig.height=10, fig.width=12}
grid.arrange(NMDS_plot_nosz1, NMDS_plot_nosz2,NMDS_plot_nifh, NMDS_plot_16S, nrow=2)

nmds_clust <- 
NMDS_nosz2 %>% 
  mutate(gene = "nosz2") %>% 
  rbind(mutate(NMDS_nosz1, gene = "nosz1")) %>%
  rbind(mutate(NMDS_16S, gene = "nifh")) %>%
  rbind(mutate(NMDS_nifh, gene = "16S")) %>% 
  ggplot(., aes(x = MDS1, y =MDS2, fill = sediment))+
  geom_point(size = 4, shape = 21, colour = "darkgrey", alpha = 0.8)+
  facet_wrap(~gene, nrow = 2)+
 # geom_label(data = filter(NMDS_16S, sample %in% c(32:36, 42)), aes(label = sample),
  #          nudge_x= 0.05, size = 6, alpha = 0.4)+
  theme_bw()+
  ggtitle("NMDS clustering of the four marker genes by habitat  - bray curtis")+
  scale_fill_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))

#ggsave("nmds_4_genes_clean.pdf", plot = nmds_clust, height = 10, width = 11)
#ggsave("nmds_4_genes_clean.png", plot = nmds_clust, height = 10, width = 11)

nmds_clust 

ecodist_plot <- arrangeGrob(PDplot_16S, PDplot_nifh, PDplot_nosz1, PDplot_nosz2)

ggsave("ecodist_pd.pdf", plot = ecodist_plot, width = 10, height = 10)
ggsave("ecodist_pd.png", plot = ecodist_plot, width = 10, height = 10)

plot(ecodist_plot)
```






# NMDS with all seasons

```{r, eval = TRUE, fig.width=12, fig.height=4}
meta_full <- read.table("metadata_old_new.txt")
arrange(meta, sample)
meta.t <- meta[! is.na(meta$sample), ]
rownames(meta.t) <- meta.t$sample

ps_16S_full <- phyloseq(otu_table(OTU_bac, taxa_are_rows = F),
                    sample_data(meta.t))

d2_16S_full <- phyloseq_to_deseq2(ps_16S_full, ~sediment + season)

Sigdiff_16S_full <- DESeq(d2_16S_full, fitType = "parametric", test = "Wald", minReplicatesForReplace = 7, quiet = T)

VST_16S_full <- assay(varianceStabilizingTransformation(Sigdiff_16S_full, blind = T))

VST_16S_full <- VST_16S_full + abs(min(VST_16S_full))

dist.full <- vegdist(t(VST_16S_full), distance = "bray")


NMDS_16S_full <- metaMDS(dist.full, autotransform = FALSE, trace = 1)

points <- NMDS_16S_full$points %>% 
  data.frame() %>% 
  rownames_to_column(var = "sample") %>% 
  mutate(sample = as.numeric(sample)) %>% 
  left_join(.,meta) 

bac <- ggplot(points, aes(x = MDS1, y =MDS2, colour = sediment , shape = season))+
  geom_point(size = 3)+
  geom_text(aes(label = sample), nudge_x= 0.02, size = 4)+
  theme_bw()+
  facet_wrap(~season)+
  ggtitle("16S composition - bray curtis")+
  scale_colour_manual(values = c("cyan4", "forestgreen", "tan2", "brown4"))

bac

#ggsave("bac.pdf", height = 10, width = 10)
```






